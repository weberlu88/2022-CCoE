RansomEXX — Analysis of the Ransomware Used in the STJ Attack
Gustavo Palazolo

8 min read
Nov 16, 2020

Thewe believe that the vast majority of Brazilians learned of a cyber attack that unfortunately occurred in the Supreme Court of Justice recently. According to the official note:

"The Superior Court of Justice (STJ) communicates that the court's information technology network suffered a hacker attack on Tuesday (3), during the afternoon, when the trial sessions of the collegiates of the six classes took place. The presidency of the court has already activated the Federal Police for the investigation of the cyber attack."

In addition to the official note, the Department of Information Security (DSI), published two notes with technical information about the attack, including the hash (MD5/SHA1) of two files:

(notepad.exe) — 9df15f471083698b818575c381e49c914dee69de
(svc-new/svc-new) — 3bf79cc3ed82edd6bfe1950b7612a20853e28b09

Despite the technical details of the note, little is known about the attack and the workings of the above artifacts.

The first of them (notepad.exe) is a loader known as Vatet, which we will leave out of the article, because it is being analyzed in the Binary Chat channel, check it out!

Still on the note, the incident had critical proportions, the IT area of the STJ recommended to users – ministers, servers, interns and outsourced – not to use computers, even personal ones, which are connected with any of the Court's computerized systems, until the security of the procedure is guaranteed.

With this in mind, I and two other friends, Ialle Teixeira and Felipe Duarte, made an analysis of the second file and decided to publish it here, with the sole purpose of showing the reverse engineering of the malware and perhaps helping people understand its operation and somehow contribute more useful information to the organs of interest.

RansomEXX
The file belongs to a family of ransomware known as RansomEXX, or Defray777. Throughout the year 2020, this ransomware became known due to major attacks, such as the one that occurred at the Texas Department of Transportation (TxDOT).

As of early November 2020, only Windows versions of RansomEXX had been detected, however, a Linux variant was recently discovered and published by Kaspersky.


DIE tool showing details about the file.
The file published by DSI is precisely a version of RansomEXX for Linux, being a 64-bit ELF binary compiled with GCC, as indicated in the image above.

The first thing to note is that the malware has no anti-parsing techniques and no obfuscation in the code or strings.


Part of the RansomEXX strings.
Another point is that the file was compiled with the debug information, that is, through reverse engineering, we can get interesting details such as variable names and methods used by the attacker.

In the following sections, we will show you the details of the main functions of RansomEXX.

main()
The malware's "main" function is responsible for:

Call the "GeneratePreData" function, which creates the encryption context;
Create a thread that performs the same function every 0.18 seconds, generating new encryption keys;
Encrypt the files of a particular path, which was passed via argument on the execution command line.

Pseudocode in C of the RansomEXX function "main()"
GeneratePreData
This function is responsible for generating the encryption key that will be used by the malware. For this, it uses an open-source library called mbedtls.


Graphical representation of the functions, generated by the IDA.
In the first step of the function, the malware generates a value that is used in the "custom" parameter of the "mbedtls_ctr_drbg_seed" function.


First part of the "GeneratePreData" function.
To do this, it calls the "time" function, which returns the current date represented in a 4-byte value, for example:


Hexadecimal value returned by the "time" function.
This value is then passed to the srand function, which will feed the four subsequent calls of the rand function. The result of these calls are then concatenated into a 32-character string, similar to an MD5 hash.


String generated by concatenating the srand + rand values.
This value is used to ensure that the initialization of the encryption key always has a different starting point, the library itself has a tutorial showing the use of this value in the "mbedtls_ctr_drbg_seed" function.


Example of using the "mbedtls_ctr_drbg_seed" method.
Finally, the author of the malware used the "mbedtls_ctr_drbg_random" function to generate a random 256-bit encryption key.


Last step of the generation of the encryption key.
The creation of the encryption key can be summarized with the following C representation:


Pseudocode in C, representing the creation of the encryption key.
As we will show later, this ransomware makes use of multiple threads to speed up the encryption process. While one thread generates the key, the other is responsible for encrypting the files. To read the key, the malware makes use of mutex, through the function pthread_mutex_lock and pthread_mutex_unlock.


Malware copying the encryption key, which will be read by another thread.
The mutex is locked, indicating to the other threads that the encryption key cannot be accessed yet;
The new encryption key is copied to a variable, which will be read by other threads;
The mutex is unlocked, indicating that the value can already be accessed.
In the function responsible for encrypting the files, which we will show throughout the post, the same logic is used:


The mutex is locked, indicating that the key is being read by the function;
The encryption key is used;
The mutex is unlocked, indicating that the address is free to receive new keys.
This logic allows that both at the time of generating the key and at the time of using it, no value is corrupted, because it can only be read / changed when the mutex is released.

In short, to encrypt the files, the malware generates a random 256-bit key every 0.18 seconds, which is read by another thread, which is encrypting the files.

Okay, but if the encryption key is dynamically generated and has a new value every 0.18 seconds, how does the attacker know which key to use when decrypting the files?

To recover the key used, the malware encrypts the value using a public RSA-4096 key that is present in the binary:


The attacker's public RSA key.
After encrypting the key, the value is saved along with the encrypted file, ensuring that only the attacker can know what value was used in the encryption, and then decrypt it.


EnumFiles
As we show in the pseudocode image of the "main", this function receives as a parameter the path of where the files to be encrypted are.


Graphical representation of the functions, generated by the IDA.
First, the function creates multiple threads that call the "encrypt_worker" function, which contains the code responsible for encrypting the files.


Malware creating threads to perform the "encrypt_worker" function.
In addition, it also calls the function "list_dir", which lists the entire directory and executes the function "ReadMeStoreForDir", which creates the ransom note in the same location, with the name "! NEWS_FOR_STJ!. txt".


Name of the ransom note.
After creating the file, the content is written using the "fwrite" function.


Contents of the ransom note.
The ransom note has information for the STJ to contact the attacker. It is worth mentioning that the email left for contact was reported as abuse and removed by ProtonMail, which may possibly make it difficult to contact the author of the attack, as we can see in the test below:


Invalid ransom note email.
CryptOneFile / CryptOneBlock
As mentioned above, the "encrypt_worker" function will run on a separate thread and will be responsible for executing the code that will effectively encrypt the file. For each file, the "CryptOneFile" function is called.


Call to CryptOneFile.
Within the "CryptOneFile", the key generated by the other thread is accessed as we showed in the steps above, initializing an AES encryption, with the functions mbedtls_aes_init and mbedtls_aes_setkey_enc.

Once initialized, the file is encrypted in blocks by the "CryptOneBlock" function, which encrypts the file using AES in ECB mode.


Call to the function that encrypts the data, using AES+ECB.
STJ vs. Texas Department of Transportation
It is also worth mentioning the comparison between the ransomware used in the attack on the Texas Department of Transportation (TxDOT), as there is a great similarity between the binaries, which are of the same family:


Function that writes the ransom note in the two executables, having only the text changed.

Function that initializes and reads the encryption key, in both executables.
In addition to raising several hypotheses, we can also realize the importance of using the intelligence generated from other incidents, such as the possibility and improvement of new protection mechanisms, such as a simple rule via YARA or any other technology.

As we can see below, the two executables have 99% similarity:


Result of the BinDiff tool, comparing the two executables.
Demonstration
To demonstrate how ransomware works, we recorded a short video running it on a Linux (Ubuntu) VM.


Demonstration of how RansomEXX works.
Conclusion
In this post we show the main technical details of the ransomware used in the attack on the STJ. The main purpose of the malware is only the encryption of the files, which is an unusual operation compared to the latest ransomware families, where there is communication with C2 and additional functionality.

We are very sorry for what happened with the STJ and hope to have contributed with some useful information, it is worth mentioning that we are at the disposal of the government to assist in any further analysis.

It is worth remembering that both the analysis of the archive and the article were produced today, November 15, 2020, in case the article has any errors, please welcome any feedback.

IOCs
Archive:

Name: svc-new/svc-new
SHA256: 08113ca015468d6c29af4e4e4754c003dacc194ce4a254e15f38060854f18867

MITRE:

Data Encrypted for Impact https://attack.mitre.org/techniques/T1486/
ID: T1486

Sources

http://www.stf.jus.br/portal/cms/verNoticiaDetalhe.asp?idConteudo=454634https://www.ctir.gov.br/arquivos/alertas/2020/alerta_especial_2020_07_atualizacao_ataques_de_ransomware.pdf
https://attack.mitre.org/techniques/T1486/
https://attack.mitre.org/mitigations/M1053/
https://www.ctir.gov.br/arquivos/alertas/2020/alerta_2020_03_ataques_de_ransomware.pdf

Text revised by Journalist Aline Palazolo Eiras.