Number,Content
Sentence 1,"Looking Closer at BPF Bytecode in BPFDoor
Metadata
SHA256: afa8a32ec29a31f152ba20a30eb483520fe50f2dce6c9aa9135d88f7c9c511d7
Malware Bazaar link
Table of Contents
Family Introduction
BPF Introduction
The Need for BPF
Stability in BPF
eBPF vs cBPF
Studying the BPF Bytecode in BPFDoor
Building Capstone
Disassembling BPF Bytecode
Interpreting BPFDoor’s BPF Bytecode
Summary
References
Family Introduction
BPFDoor is a backdoor targeting Linux-based systems."
Sentence 2,It leverages Berkeley Packet Filter (BPF) technology that exists natively in Linux kernels since v2.1.75.
Sentence 3,"By using low-level BPF-based packet filtering, it is able to bypass local firewalls and stealthily receive network traffic from its C2."
Sentence 4,"BPF Introduction
The Need for BPF
An operating system (OS) abstracts away the hardware."
Sentence 5,"For example, user-space programs running on the OS do not directly interact with networking-related hardware."
Sentence 6,They do so via APIs exposed by the OS.
Sentence 7,"On Linux, these are called system calls or syscalls, in short."
Sentence 8,This kind of a design results in a clear demarcation between the user-space and kernel-space.
Sentence 9,Consider a single network packet that reaches the kernel.
Sentence 10,A user-space packet filtering program wants to look at it.
Sentence 11,"In this case, the contents of the entire packet needs to be copied into user-space memory for it to be accessible by the user-space program."
Sentence 12,This incurs a cost in performance and can be expected to be significant on high-traffic systems.
Sentence 13,"With the introduction of BPF in Linux kernel v2.1.75, packet filtering can occur in kernel-space."
Sentence 14,A user-space application such as tcpdump could provide a filtering program (aka BPF program) which would be compiled and run completely in kernel-space in a register-based VM.
Sentence 15,This avoids the performance cost of copying the network packet into user-space.
Sentence 16,"Stability in BPF
To avoid instability in kernel-space, an arbitrary BPF program cannot be provided."
Sentence 17,A number of checks are performed by the BPF in-kernel verifier.
Sentence 18,"This includes tests such as verifying that the BPF program terminates, registers are initialized and the program does not contain any loops that could cause the kernel to lock up."
Sentence 19,A BPF program can successfully be loaded and executed only after it is verified.
Sentence 20,"eBPF vs cBPF
The original BPF, also called classic BPF (cBPF), was designed for capturing and filtering network packets that matched specific rules."
Sentence 21,Linux kernel v3.15 then introduced extended BPF (eBPF) which was more versatile and powerful.
Sentence 22,"It had a larger instruction set, leveraged 64-bit registers and more number of them."
Sentence 23,It could also be leveraged for carrying out system performance analysis.
Sentence 24,"tcpdump, a user-space network packet analyzer, generates cBPF bytecode but it is then translated to eBPF bytecode in recent kernels."
Sentence 25,The following is an example of cBPF instructions generated by tcpdump when capturing TCP traffic on port 80.
Sentence 26,I’ve also added the C-style bytecode equivalent (-dd option in tcpdump) for each instruction.
Sentence 27,"$ sudo tcpdump -i wlp4s0 -d tcp port 80
(000) ldh      [12]                             # { 0x28, 0, 0, 0x0000000c }
(001) jeq      #0x86dd          jt 2   jf 8     # { 0x15, 0, 6, 0x000086dd }
(002) ldb      [20]                             # { 0x30, 0, 0, 0x00000014 }
(003) jeq      #0x6             jt 4   jf 19    # { 0x15, 0, 15, 0x00000006 }
(004) ldh      [54]                             # { 0x28, 0, 0, 0x00000036 }
(005) jeq      #0x50            jt 18  jf 6     # { 0x15, 12, 0, 0x00000050 }
(006) ldh      [56]                             # { 0x28, 0, 0, 0x00000038 }
(007) jeq      #0x50            jt 18  jf 19    # { 0x15, 10, 11, 0x00000050 }
(008) jeq      #0x800           jt 9   jf 19    # { 0x15, 0, 10, 0x00000800 }
(009) ldb      [23]                             # { 0x30, 0, 0, 0x00000017 }
(010) jeq      #0x6             jt 11  jf 19    # { 0x15, 0, 8, 0x00000006 }
(011) ldh      [20]                             # { 0x28, 0, 0, 0x00000014 }
(012) jset     #0x1fff          jt 19  jf 13    # { 0x45, 6, 0, 0x00001fff }
(013) ldxb     4*([14]&0xf)                     # { 0xb1, 0, 0, 0x0000000e }
(014) ldh      [x + 14]                         # { 0x48, 0, 0, 0x0000000e }
(015) jeq      #0x50            jt 18  jf 16    # { 0x15, 2, 0, 0x00000050 }
(016) ldh      [x + 16]                         # { 0x48, 0, 0, 0x00000010 }
(017) jeq      #0x50            jt 18  jf 19    # { 0x15, 0, 1, 0x00000050 }
(018) ret      #262144                          # { 0x6, 0, 0, 0x00040000 }
(019) ret      #0                               # { 0x6, 0, 0, 0x00000000 }
Studying the BPF Bytecode in BPFDoor
Building Capstone
Given BPF bytecode, we can use capstone to disassemble it."
Sentence 28,It supports the disassembly of both cBPF and eBPF bytecode.
Sentence 29,Building capstone from source is simple.
Sentence 30,"$ git clone --recursive https://github.com/capstone-engine/capstone
Cloning into 'capstone'...
remote: Enumerating objects: 32768, done."
Sentence 31,"remote: Counting objects: 100% (1765/1765), done."
Sentence 32,"remote: Compressing objects: 100% (544/544), done."
Sentence 33,"remote: Total 32768 (delta 1267), reused 1649 (delta 1206), pack-reused 31003
Receiving objects: 100% (32768/32768), 50.82 MiB | 18.05 MiB/s, done."
Sentence 34,"Resolving deltas: 100% (23271/23271), done."
Sentence 35,"$ cd capstone
$ ./make.sh
$ cd bindings/python/
$ sudo make install

$ pip freeze | grep capstone
capstone==5.0.0rc2
Disassembling BPF Bytecode
The following snap shows the existence of cBPF bytecode of length 240 bytes in the BPFDoor sample."
Sentence 36,The cBPF program is applied on the socket using a call to setsockopt with SO_ATTACH_FILTER option and a pointer to the cBPF bytecode.
Sentence 37,"BPF Bytecode in BPFDoor

$ xxd -c 8 -g 1 bpf.o
00000000: 28 00 00 00 0c 00 00 00  (.......
00000008: 15 00 00 09 dd 86 00 00  ........
00000010: 30 00 00 00 14 00 00 00  0.......
00000018: 15 00 00 02 06 00 00 00  ........
00000020: 28 00 00 00 38 00 00 00  (...8...
00000028: 15 00 16 0d 50 00 00 00  ....P...
00000030: 15 00 16 00 2c 00 00 00  ....,...
00000038: 15 00 01 00 84 00 00 00  ........
00000040: 15 00 00 14 11 00 00 00  ........
00000048: 28 00 00 00 38 00 00 00  (...8...
00000050: 15 00 11 10 bb 01 00 00  ........
00000058: 15 00 00 11 00 08 00 00  ........
00000060: 30 00 00 00 17 00 00 00  0.......
00000068: 15 00 00 06 06 00 00 00  ........
00000070: 28 00 00 00 14 00 00 00  (.......
00000078: 45 00 0d 00 ff 1f 00 00  E.......
00000080: b1 00 00 00 0e 00 00 00  ........
00000088: 48 00 00 00 10 00 00 00  H.......
00000090: 15 00 09 00 50 00 00 00  ....P...
00000098: 15 00 08 07 bb 01 00 00  ........
000000a0: 15 00 01 00 84 00 00 00  ........
000000a8: 15 00 00 07 11 00 00 00  ........
000000b0: 28 00 00 00 14 00 00 00  (.......
000000b8: 45 00 05 00 ff 1f 00 00  E.......
000000c0: b1 00 00 00 0e 00 00 00  ........
000000c8: 48 00 00 00 10 00 00 00  H.......
000000d0: 15 00 01 00 bb 01 00 00  ........
000000d8: 15 00 00 01 16 00 00 00  ........
000000e0: 06 00 00 00 00 00 04 00  ........
000000e8: 06 00 00 00 00 00 00 00  ........
A BPF instruction is 8 bytes in length."
Sentence 38,I’ve formatted the above hex dump so that each line represents a cBPF instruction.
Sentence 39,capstone can be used to disassemble this bytecode.
Sentence 40,"In [1]: from capstone import *

In [2]: md = Cs(CS_ARCH_BPF, CS_MODE_BPF_CLASSIC)

In [3]: with open(bpf.o, rb) as ff:
   ...:     data = ff.read()
   ...: linenum = 0
   ...: for i in md.disasm(data, 0):
   ...:     print(f{j}: {i.mnemonic} {i.op_str})
   ...:     linenum += 1

0: ldh [0xc]
1: jeq 0x86dd, +0x0, +0x9
2: ldb [0x14]
3: jeq 0x6, +0x0, +0x2
4: ldh [0x38]
5: jeq 0x50, +0x16, +0xd
6: jeq 0x2c, +0x16, +0x0
7: jeq 0x84, +0x1, +0x0
8: jeq 0x11, +0x0, +0x14
9: ldh [0x38]
10: jeq 0x1bb, +0x11, +0x10
11: jeq 0x800, +0x0, +0x11
12: ldb [0x17]
13: jeq 0x6, +0x0, +0x6
14: ldh [0x14]
15: jset 0x1fff, +0xd, +0x0
capstone failed to disassemble the 17th instruction."
Sentence 41,"This corresponds to the cBPF bytecode:

b1 00 00 00 0e 00 00 00
Looking at the cBPF bytecode generated by tcpdump earlier (see eBPF vs cBPF section), the above bytecode corresponds to the following instruction."
Sentence 42,"Perhaps, capstone is not yet aware of this bytecode-instruction mapping."
Sentence 43,"ldxb     4*([14]&0xf)
I removed the above ldxb instruction-specific bytecode from the hex dump, disassembled the remaining bytecode using capstone and then added the ldxb instruction at the appropriate position in the instruction sequence."
Sentence 44,"0: ldh [0xc]
1: jeq 0x86dd, +0x0, +0x9
2: ldb [0x14]
3: jeq 0x6 , +0x0, +0x2
4: ldh [0x38]
5: jeq 0x50, +0x16, +0xd
6: jeq 0x2c, +0x16, +0x0
7: jeq 0x84, +0x1, +0x0
8: jeq 0x11, +0x0, +0x14
9: ldh [0x38]
10: jeq 0x1bb, +0x11, +0x10
11: jeq 0x800, +0x0, +0x11
12: ldb [0x17]
13: jeq 0x6, +0x0, +0x6
14: ldh [0x14]
15: jset 0x1fff, +0xd, +0x0
16: ldxb 4*([14]&0xf)
17: ldh [x+0x10]
18: jeq 0x50, +0x9, +0x0
19: jeq 0x1bb, +0x8, +0x7
20: jeq 0x84, +0x1, +0x0
21: jeq 0x11, +0x0, +0x7
22: ldh [0x14]
23: jset 0x1fff, +0x5, +0x0
24: ldxb 4*([14]&0xf)
25: ldh [x+0x10]
26: jeq 0x1bb, +0x1, +0x0
27: jeq 0x16, +0x0, +0x1
28: ret 0x40000
29: ret 0x0
Interpreting BPFDoor’s BPF Bytecode
BPFDoor attaches the cBPF program to a AF_PACKET socket."
Sentence 45,"So, packet filtering occurs at layer 2 of the network stack."
Sentence 46,Let’s look at each instruction line-by-line.
Sentence 47,"0: ldh [0xc]
Line 0 Instruction

1: jeq 0x86dd, +0x0, +0x9
Line 1 Instruction

2: ldb [0x14]
Line 2 Instruction

3: jeq 0x6 , +0x0, +0x2
Line 3 Instruction

4: ldh [0x38]
Line 4 Instruction

5: jeq 0x50, +0x16, +0xd
If the previously loaded value at line 4 matches 0x50, control jumps to line 28 (relative offset 0x16) else it jumps to line 19 (relative offset 0xd)."
Sentence 48,This instruction checks if the destination port number is 80.
Sentence 49,"6: jeq 0x2c, +0x16, +0x0
Line 6 Instruction

7: jeq 0x84, +0x1, +0x0
Line 7 Instruction

8: jeq 0x11, +0x0, +0x14
Line 8 Instruction

9: ldh [0x38]
Line 9 Instruction

10: jeq 0x1bb, +0x11, +0x10
If the previously loaded value at line 9 matches 0x1bb, control jumps to line 28 (relative offset 0x11) else it jumps to line 27 (relative offset 0x10)."
Sentence 50,"This instruction checks if the destination port number is 443

11: jeq 0x800, +0x0, +0x11
Line 11 Instruction

12: ldb [0x17]
Line 12 Instruction

13: jeq 0x6, +0x0, +0x6
Line 13 Instruction

14: ldh [0x14]
Line 14 Instruction

15: jset 0x1fff, +0xd, +0x0
This instruction performs a bitwise AND operation between the previously loaded value at line 14 and 0x1fff."
Sentence 51,"If the result is non-zero, control jumps to line 29 (relative offset 0xd) else line 16 (relative offset 0)."
Sentence 52,This instruction basically looks at the value of the Fragment Offset field.
Sentence 53,"If it is non-zero, control jumps to line 29 else line 16."
Sentence 54,"16: ldxb 4*([14]&0xf)
Line 16 Instruction

17: ldh [x+0x10]
Line 17 Instruction

18: jeq 0x50, +0x9, +0x0
If the previously loaded value at line 17 matches 0x50, control jumps to line 28 (relative offset 0x9) else it jumps to line 19 (relative offset 0)."
Sentence 55,This instruction checks if the destination port number is 80.
Sentence 56,"19: jeq 0x1bb, +0x8, +0x7
If the previously loaded value at line 17 matches 0x1bb, control jumps to line 28 (relative offset 0x8) else it jumps to line 27 (relative offset 0x7)."
Sentence 57,This instruction checks if the destination port number is 443.
Sentence 58,"20: jeq 0x84, +0x1, +0x0
Line 20 Instruction

21: jeq 0x11, +0x0, +0x7
Line 21 Instruction

22: ldh [0x14]
Line 22 Instruction

23: jset 0x1fff, +0x5, +0x0
This instruction performs a bitwise AND operation between the previously loaded value at line 14 and 0x1fff."
Sentence 59,"If the result is non-zero, control jumps to line 29 (relative offset 0x5) else line 24 (relative offset 0)."
Sentence 60,This instruction basically looks at the value of the Fragment Offset field.
Sentence 61,"If it is non-zero, control jumps to line 29 else line 24."
Sentence 62,"24: ldxb 4*([14]&0xf)
Line 24 Instruction

25: ldh [x+0x10]
Line 25 Instruction

26: jeq 0x1bb, +0x1, +0x0
If the previously loaded value at line 25 matches 0x1bb, control jumps to line 28 (relative offset 0x1) else it jumps to line 27 (relative offset 0)."
Sentence 63,This instruction checks if the destination port number is 443.
Sentence 64,"27: jeq 0x16, +0x0, +0x1
If the previously loaded value matches 0x16, control jumps to line 28 (relative offset 0) else it jumps to line 29 (relative offset 0x1)."
Sentence 65,This instruction checks if the destination port number is 22.
Sentence 66,"28: ret 0x40000
A non-zero return indicates a packet match."
Sentence 67,"29: ret 0x0
A zero return indicates a packet no-match."
Sentence 68,"Summary
BPFDoor’s cBPF bytecode filters according to the following rules:

Match only on IPv4 or IPv6 packets."
Sentence 69,"Match only on TCP traffic on ports 80, 443 and 22."
Sentence 70,"In case of IPv4, don’t match on fragmented packets."
Sentence 71,There is no TCP fragmentation over IPv6.
Sentence 72,Match only on UDP/SCTP traffic on ports 443 and 22.
Sentence 73,In both IPv4 and IPv6 don’t match on fragmented packets.
Sentence 74,I think DeepInstinct’s blog about BPFDoor missed to point out that UDP traffic on only ports 443 and 22 are captured and not port 80.
Sentence 75,"BPFdoor guides the kernel to set up its socket to only read UDP, TCP, and SCTP traffic coming through ports 22 (ssh), 80 (http), and 443 (https)."
Sentence 76,The flowchart below shows the overall control flow of the BPF program:
