asg_object: ['0x[0-9a-zA-Z]{1,16}', '^GID.*', '^PID.*', '^UID.*', '^dmesg$', '^insmod$', '^sh$']

Sample FontOnLake.csv
	num of segment in report: 42, 11 of them contain ASG object(s)
	lenght of ctd's OPset is 32
	#numofSTobject: 1, numofSTobject sysRrc: 0
	#R_malObj
	num of ctd objects: 6, num of asg objects: 22. R_malObj is 0.2727
		ctd_object: ['0x[0-9a-zA-Z]{1,16}', '^PID.*', '^UID.*']
	#R_malSysObj
	num of ctd objects: 0, num of asg objects: 0. R_malSysObj is 0.0000
		len(asg_OPset): 15, len(ctd_OPset): 32
	#R_malOps
	num of matched asg op: 19, num of asg op: 73. R_malOps is 0.2603
		refered lifecycle: [1, 2, 7, 9, 12, 13, 14]
	#R_malChangeOps
	num of matched asg op: 0, num of asg op: 0. R_malChangeOps is 0.0000
		ref-sys lifecycle: []

	hits
	<OP 2 act=mprotect(), obj=0x[0-9a-zA-Z]{1,16} (mem)>, <OP16 act=run, obj=0x300Executes, sent=release>|<uname.machine>|<ethernet_address> is sent  It also acquires all the credentials from the virtual file and sends them back one by one  Command structures Currently supported commands are described Table 7  Table 7 // Layer 1 commands of Backdoor 3 ID Description 0x100 Serves as a heartbeat and acquires all the credentials from the virtual file and sends them back one by one  0x101 Forwards the commands to the next layer   0x107 Exits  0x108 Closes all remote sessions and shells tied to a supplied unique ID   0x407 Forwards received data to a session tied to a supplied unique ID   0x408 Terminates Python script to be executed by the next command  0x409Uses a short Python script, which is presented in “Appendix 3”, to download and execute additional task – Python script   according to the extension from an FTP server protected with hardcoded credentials  The name of the file to be downloaded  is in the format tasks/<task_name>.py, where <task_name> is received  Only one such script can run at a time  Table 8 // Layer 2 commands of Backdoor 3 ID Description 0x300Executes supplied shell command and mediates subsequent I/O, each executed command is identified with a supplied  unique ID   If there is already one shell for the supplied unique ID, message hostid already connected  is sent back  0x301 Removes and terminates a shell session for a supplied unique ID   0x302Forwards a message to certain shell session based on supplied unique ID   If it failed to find such shell session, message no  find shell hostid!>
	<OP 3 act=arch_prctl(), obj=0x[0-9a-zA-Z]{1,16} (mem)>, <OP16 act=run, obj=0x300Executes, sent=release>|<uname.machine>|<ethernet_address> is sent  It also acquires all the credentials from the virtual file and sends them back one by one  Command structures Currently supported commands are described Table 7  Table 7 // Layer 1 commands of Backdoor 3 ID Description 0x100 Serves as a heartbeat and acquires all the credentials from the virtual file and sends them back one by one  0x101 Forwards the commands to the next layer   0x107 Exits  0x108 Closes all remote sessions and shells tied to a supplied unique ID   0x407 Forwards received data to a session tied to a supplied unique ID   0x408 Terminates Python script to be executed by the next command  0x409Uses a short Python script, which is presented in “Appendix 3”, to download and execute additional task – Python script   according to the extension from an FTP server protected with hardcoded credentials  The name of the file to be downloaded  is in the format tasks/<task_name>.py, where <task_name> is received  Only one such script can run at a time  Table 8 // Layer 2 commands of Backdoor 3 ID Description 0x300Executes supplied shell command and mediates subsequent I/O, each executed command is identified with a supplied  unique ID   If there is already one shell for the supplied unique ID, message hostid already connected  is sent back  0x301 Removes and terminates a shell session for a supplied unique ID   0x302Forwards a message to certain shell session based on supplied unique ID   If it failed to find such shell session, message no  find shell hostid!>
	<OP 8 act=getuid(), obj=^UID.*>, <OP27 act=get, obj=UID, sent=inject.so inject.so overrides system calls execve, fork and bash to conceal output of the ss tool and log bash   history  It unsets environment variable LD_PRELOAD to block attempts to use the LD_PRELOAD trick on the  executable running this library  It checks whether the file it runs under is /bin/bash whose command line is -bash, i e , the default  shell or /usr/bin/ss  In such cases, it hooks fork – executes the original fork acquired by dlsym with  RTLD_DEFAULT and unsets the indicators that it runs under bash or ss in the child process, but they can  be still set later   If it runs under ss, it hooks execve; the hook calls the original execve with output filtered through  pipes, searches for its non-standard ports, and discards them from the output  If it runs under bash, function bash_add_history, whose address is acquired by dlsym with RTLD_ DEFAULT, default library search order, is hooked using the subhook library  The hook calls the real bash_ add_history and acquires symbol current_user using dlsym with RTLD_DEFAULT  The symbol is  used to get UID <bash_uid> and GUID <bash_guid> present in bash in the current_user structure  and writes |1|<time_since_epoch>|<ppid>|<pid>|<sid>|<bash_uid>|<bash_gid>|<history_ entry> to the virtual file  The rootkit generates a random name following its filename pattern, notes the file-path and writes the  embedded file to the location  It also sets permissions of the file to 755  It has no other use currently; it  is apparently under development  Empty  alloc_pid hook The rootkit uses method register_kretprobe to register kretprobe for alloc_pid symbol_name; it  does not register any handler and it does not seem to use it anywhere in the code, which suggests that  it might be some functionality in development  It is most likely going to be used with the shared library injection functionality somehow  Termination of hidden processes When one of the hidden processes is to be terminated, it needs to remove its PID from the list of PIDs to  be hidden  This is achieved by using method register_kprobe to register kprobe for do_exit symbol_name:  it registers a pre_handler that checks whether the PID of process to exit is present in the list of PIDs  to be hidden  In that case, it removes the PID from the list  Additionally, if the PID belongs to the main  backdoor, it sets a variable indicating that there is no main backdoor – it is required to enable an  updated one to register itself  Hiding memory regions To hide memory regions mapped from its files, the rootkit uses method register_kretprobe to  register kretprobe for seq_path symbol_name, it registers both handler and entry_handler and sets  data_size to 8: • entry_handler – instructs kernel threads to be skipped: a kernel thread is recognized by checking  whether mm structure of the current task_struct is a null pointer   It also moves the DI register, which  is the first parameter – seq_file, to the kretprobe_instance data  • handler – instructs kernel threads to be skipped in the same way as before  If the last entry contains  the substring /tmp/.tmp_, it trims it, which effectively hides the presence of memory-mapped  regions, unless the PID of the caller belongs to the main backdoor   It seems that this technique has not been documented yet  The method seq_path is used especially  by show_map, which lists memory regions in /proc/<PID>/maps  It is most likely supposed to hide its  libraries that are injected to other, legitimate processes  Figure 11 // Hex-Rays decompilation of the seq_path handler Hiding processes and files The rootkit overrides the system call getdents to hide certain processes and files as in the previous  version  In comparison to the other version, it hides more files – the rootkit and those following its  filename format (/tmp/.tmp_<random>) that weren’t present on-disk in the other version  The main modifications are in filldir, which is used by getdents: it skips further processing and  returns to hide the target file if it is: • under /proc and is the virtual file or present in the list of the PIDs to be hidden  • under /tmp, begins with .tmp_ and the PID of the caller does not belong to the main backdoor   • /lib/modules/kernel_ver/kernel/drivers/input/misc/ati_remote3.ko or /etc/ sysconfig/modules/ati_remote3.modules  Hiding network connections The rootkit hooks tcp4_seq_show() seq_operation in the same way as in the other version to hide its  network connections  Hiding itself (its own kernel module) seq_show() seq_operation of /proc/modules is hooked by the rootkit to hide itself from the list  This  is achieved by calling the original one and checking the result for ati_remote3.ko; if it is found, the  last entry is discarded – it is not known what the reason for this is, since the next step would hide it  from the output of /proc/modules implicitly  It also unlinks its kobject via the kobject_del() method, which will hide it from the lsmod command  executed as root as well  Update mechanism To update, the rootkit terminates the main running backdoor and removes its on-disk file; it  subsequently copies the updated version downloaded by the backdoor to the original location, sets its  permissions to 755, and executes it with command line [khelper]   If the process fails for whatever reason, it generates a random name following its filename format,  writes the original embedded backdoor to the file and executes it in the same way  CONCLUSION We have found and described a set of malicious and at the time of discovery unknown tools which do  not seem to belong to any recognized malware family  Their scale and advanced design suggest that the  authors are well versed in cybersecurity and that these tools might be reused in future campaigns  As most of the features are designed just to hide its presence, relay communication, and provide  backdoor access, we believe that these tools are used mostly to maintain an infrastructure which serves  some other, unknown, malicious purposes  In the past we described an operation that shared certain behavioral patterns; similarly, it collected  sshd credentials to compromise further machines, built its infrastructure out of afflicted servers and  injected a dynamic library using DT _NEEDED into processes, which hooked execve as well  However, its  scale and impact were much greater   If interested, you can read about Operation Windigo in this white  paper and this follow-up blogpost   IOCS   Samples  SHA-1 Description Detection name 1F52DB8E3FC3040C017928F5FFD99D9FA4757BF8 Trojanized cat Linux/FontOnLake771340752985DD8E84CF3843C9843EF7A76A39E7 Trojanized kill 27E868C0505144F0708170DF701D7C1AE8E1FAEA Trojanized sftp 45E94ABEDAD8C0044A43FF6D72A5C44C6ABD9378 Trojanized sshd 1829B0E34807765F2B254EA5514D7BB587AECA3F Custom sshd 8D6ACA824D1A717AE908669E356E2D4BB6F857B0 Custom sshd 38B09D690FAFE81E964CBD45EC7CF20DCB296B4D Backdoor 1 56556A53741111C04853A5E84744807EEADFF63A Backdoor 1 FE26CB98AA1416A8B1F6CED4AC1B5400517257B2 Backdoor 1 D4E0E38EC69CBB71475D8A22EDB428C3E955A5EA Backdoor 1 204046B3279B487863738DDB17CBB6718AF2A83A Backdoor 2 9C803D1E39F335F213F367A84D3DF6150E5FE172 Backdoor 2 BFCC4E6628B63C92BC46219937EA7582EA6FBB41 Backdoor 2 515CFB5CB760D3A1DA31E9F906EA7F84F17C5136 Backdoor 3 A9ED0837E3AF698906B229CA28B988010BCD5DC1 Backdoor 3 56CB85675FE7A7896F0AA5365FF391AC376D9953 Rootkit version 1 72C9C5CE50A38D0A2B9CEF6ADEAB1008BFF12496 Rootkit version 1 B439A503D68AD7164E0F32B03243A593312040F8 Rootkit version 1 E7BF0A35C2CD79A658615E312D35BBCFF9782672 Rootkit version 1 56580E7BA6BF26D878C538985A6DC62CA094CD04 Rootkit version 1 49D4E5FCD3A3018A88F329AE47EF4C87C6A2D27A Rootkit version 1 74D44C2949DA7D5164ADEC78801733680DA8C110 Rootkit version 2 74D755E8566340A752B1DB603EF468253ADAB6BD Rootkit version 2 E20F87497023E3454B5B1A22FE6C5A5501EAE2CB Rootkit version 2 6F43C598CD9E63F550FF4E6EF51500E47D0211F3 inject.so C&Cs From samples: 47.107.60[>
	<OP10 act=geteuid(), obj=^UID.*>, <OP27 act=get, obj=UID, sent=inject.so inject.so overrides system calls execve, fork and bash to conceal output of the ss tool and log bash   history  It unsets environment variable LD_PRELOAD to block attempts to use the LD_PRELOAD trick on the  executable running this library  It checks whether the file it runs under is /bin/bash whose command line is -bash, i e , the default  shell or /usr/bin/ss  In such cases, it hooks fork – executes the original fork acquired by dlsym with  RTLD_DEFAULT and unsets the indicators that it runs under bash or ss in the child process, but they can  be still set later   If it runs under ss, it hooks execve; the hook calls the original execve with output filtered through  pipes, searches for its non-standard ports, and discards them from the output  If it runs under bash, function bash_add_history, whose address is acquired by dlsym with RTLD_ DEFAULT, default library search order, is hooked using the subhook library  The hook calls the real bash_ add_history and acquires symbol current_user using dlsym with RTLD_DEFAULT  The symbol is  used to get UID <bash_uid> and GUID <bash_guid> present in bash in the current_user structure  and writes |1|<time_since_epoch>|<ppid>|<pid>|<sid>|<bash_uid>|<bash_gid>|<history_ entry> to the virtual file  The rootkit generates a random name following its filename pattern, notes the file-path and writes the  embedded file to the location  It also sets permissions of the file to 755  It has no other use currently; it  is apparently under development  Empty  alloc_pid hook The rootkit uses method register_kretprobe to register kretprobe for alloc_pid symbol_name; it  does not register any handler and it does not seem to use it anywhere in the code, which suggests that  it might be some functionality in development  It is most likely going to be used with the shared library injection functionality somehow  Termination of hidden processes When one of the hidden processes is to be terminated, it needs to remove its PID from the list of PIDs to  be hidden  This is achieved by using method register_kprobe to register kprobe for do_exit symbol_name:  it registers a pre_handler that checks whether the PID of process to exit is present in the list of PIDs  to be hidden  In that case, it removes the PID from the list  Additionally, if the PID belongs to the main  backdoor, it sets a variable indicating that there is no main backdoor – it is required to enable an  updated one to register itself  Hiding memory regions To hide memory regions mapped from its files, the rootkit uses method register_kretprobe to  register kretprobe for seq_path symbol_name, it registers both handler and entry_handler and sets  data_size to 8: • entry_handler – instructs kernel threads to be skipped: a kernel thread is recognized by checking  whether mm structure of the current task_struct is a null pointer   It also moves the DI register, which  is the first parameter – seq_file, to the kretprobe_instance data  • handler – instructs kernel threads to be skipped in the same way as before  If the last entry contains  the substring /tmp/.tmp_, it trims it, which effectively hides the presence of memory-mapped  regions, unless the PID of the caller belongs to the main backdoor   It seems that this technique has not been documented yet  The method seq_path is used especially  by show_map, which lists memory regions in /proc/<PID>/maps  It is most likely supposed to hide its  libraries that are injected to other, legitimate processes  Figure 11 // Hex-Rays decompilation of the seq_path handler Hiding processes and files The rootkit overrides the system call getdents to hide certain processes and files as in the previous  version  In comparison to the other version, it hides more files – the rootkit and those following its  filename format (/tmp/.tmp_<random>) that weren’t present on-disk in the other version  The main modifications are in filldir, which is used by getdents: it skips further processing and  returns to hide the target file if it is: • under /proc and is the virtual file or present in the list of the PIDs to be hidden  • under /tmp, begins with .tmp_ and the PID of the caller does not belong to the main backdoor   • /lib/modules/kernel_ver/kernel/drivers/input/misc/ati_remote3.ko or /etc/ sysconfig/modules/ati_remote3.modules  Hiding network connections The rootkit hooks tcp4_seq_show() seq_operation in the same way as in the other version to hide its  network connections  Hiding itself (its own kernel module) seq_show() seq_operation of /proc/modules is hooked by the rootkit to hide itself from the list  This  is achieved by calling the original one and checking the result for ati_remote3.ko; if it is found, the  last entry is discarded – it is not known what the reason for this is, since the next step would hide it  from the output of /proc/modules implicitly  It also unlinks its kobject via the kobject_del() method, which will hide it from the lsmod command  executed as root as well  Update mechanism To update, the rootkit terminates the main running backdoor and removes its on-disk file; it  subsequently copies the updated version downloaded by the backdoor to the original location, sets its  permissions to 755, and executes it with command line [khelper]   If the process fails for whatever reason, it generates a random name following its filename format,  writes the original embedded backdoor to the file and executes it in the same way  CONCLUSION We have found and described a set of malicious and at the time of discovery unknown tools which do  not seem to belong to any recognized malware family  Their scale and advanced design suggest that the  authors are well versed in cybersecurity and that these tools might be reused in future campaigns  As most of the features are designed just to hide its presence, relay communication, and provide  backdoor access, we believe that these tools are used mostly to maintain an infrastructure which serves  some other, unknown, malicious purposes  In the past we described an operation that shared certain behavioral patterns; similarly, it collected  sshd credentials to compromise further machines, built its infrastructure out of afflicted servers and  injected a dynamic library using DT _NEEDED into processes, which hooked execve as well  However, its  scale and impact were much greater   If interested, you can read about Operation Windigo in this white  paper and this follow-up blogpost   IOCS   Samples  SHA-1 Description Detection name 1F52DB8E3FC3040C017928F5FFD99D9FA4757BF8 Trojanized cat Linux/FontOnLake771340752985DD8E84CF3843C9843EF7A76A39E7 Trojanized kill 27E868C0505144F0708170DF701D7C1AE8E1FAEA Trojanized sftp 45E94ABEDAD8C0044A43FF6D72A5C44C6ABD9378 Trojanized sshd 1829B0E34807765F2B254EA5514D7BB587AECA3F Custom sshd 8D6ACA824D1A717AE908669E356E2D4BB6F857B0 Custom sshd 38B09D690FAFE81E964CBD45EC7CF20DCB296B4D Backdoor 1 56556A53741111C04853A5E84744807EEADFF63A Backdoor 1 FE26CB98AA1416A8B1F6CED4AC1B5400517257B2 Backdoor 1 D4E0E38EC69CBB71475D8A22EDB428C3E955A5EA Backdoor 1 204046B3279B487863738DDB17CBB6718AF2A83A Backdoor 2 9C803D1E39F335F213F367A84D3DF6150E5FE172 Backdoor 2 BFCC4E6628B63C92BC46219937EA7582EA6FBB41 Backdoor 2 515CFB5CB760D3A1DA31E9F906EA7F84F17C5136 Backdoor 3 A9ED0837E3AF698906B229CA28B988010BCD5DC1 Backdoor 3 56CB85675FE7A7896F0AA5365FF391AC376D9953 Rootkit version 1 72C9C5CE50A38D0A2B9CEF6ADEAB1008BFF12496 Rootkit version 1 B439A503D68AD7164E0F32B03243A593312040F8 Rootkit version 1 E7BF0A35C2CD79A658615E312D35BBCFF9782672 Rootkit version 1 56580E7BA6BF26D878C538985A6DC62CA094CD04 Rootkit version 1 49D4E5FCD3A3018A88F329AE47EF4C87C6A2D27A Rootkit version 1 74D44C2949DA7D5164ADEC78801733680DA8C110 Rootkit version 2 74D755E8566340A752B1DB603EF468253ADAB6BD Rootkit version 2 E20F87497023E3454B5B1A22FE6C5A5501EAE2CB Rootkit version 2 6F43C598CD9E63F550FF4E6EF51500E47D0211F3 inject.so C&Cs From samples: 47.107.60[>
	<OP13 act=set_tid_address(), obj=0x[0-9a-zA-Z]{1,16} (mem)>, <OP16 act=run, obj=0x300Executes, sent=release>|<uname.machine>|<ethernet_address> is sent  It also acquires all the credentials from the virtual file and sends them back one by one  Command structures Currently supported commands are described Table 7  Table 7 // Layer 1 commands of Backdoor 3 ID Description 0x100 Serves as a heartbeat and acquires all the credentials from the virtual file and sends them back one by one  0x101 Forwards the commands to the next layer   0x107 Exits  0x108 Closes all remote sessions and shells tied to a supplied unique ID   0x407 Forwards received data to a session tied to a supplied unique ID   0x408 Terminates Python script to be executed by the next command  0x409Uses a short Python script, which is presented in “Appendix 3”, to download and execute additional task – Python script   according to the extension from an FTP server protected with hardcoded credentials  The name of the file to be downloaded  is in the format tasks/<task_name>.py, where <task_name> is received  Only one such script can run at a time  Table 8 // Layer 2 commands of Backdoor 3 ID Description 0x300Executes supplied shell command and mediates subsequent I/O, each executed command is identified with a supplied  unique ID   If there is already one shell for the supplied unique ID, message hostid already connected  is sent back  0x301 Removes and terminates a shell session for a supplied unique ID   0x302Forwards a message to certain shell session based on supplied unique ID   If it failed to find such shell session, message no  find shell hostid!>
	<OP14 act=set_robust_list(), obj=0x[0-9a-zA-Z]{1,16} (mem)>, <OP16 act=run, obj=0x300Executes, sent=release>|<uname.machine>|<ethernet_address> is sent  It also acquires all the credentials from the virtual file and sends them back one by one  Command structures Currently supported commands are described Table 7  Table 7 // Layer 1 commands of Backdoor 3 ID Description 0x100 Serves as a heartbeat and acquires all the credentials from the virtual file and sends them back one by one  0x101 Forwards the commands to the next layer   0x107 Exits  0x108 Closes all remote sessions and shells tied to a supplied unique ID   0x407 Forwards received data to a session tied to a supplied unique ID   0x408 Terminates Python script to be executed by the next command  0x409Uses a short Python script, which is presented in “Appendix 3”, to download and execute additional task – Python script   according to the extension from an FTP server protected with hardcoded credentials  The name of the file to be downloaded  is in the format tasks/<task_name>.py, where <task_name> is received  Only one such script can run at a time  Table 8 // Layer 2 commands of Backdoor 3 ID Description 0x300Executes supplied shell command and mediates subsequent I/O, each executed command is identified with a supplied  unique ID   If there is already one shell for the supplied unique ID, message hostid already connected  is sent back  0x301 Removes and terminates a shell session for a supplied unique ID   0x302Forwards a message to certain shell session based on supplied unique ID   If it failed to find such shell session, message no  find shell hostid!>
	<OP15 act=futex(), obj=0x[0-9a-zA-Z]{1,16} (mem)>, <OP18 act=route, obj=0x401, sent=(sic) is sent back  0x400Establishes proxy connection to a supplied endpoint  Each connection is represented by two unique IDs – we suspect that  one represents endpoint ID and the other a connection ID   The operators can effectively route traffic of multiple machines  through the victim  0x401 Terminates a proxy session for supplied unique ID   0x402Forwards a message to a certain proxy session based on supplied unique IDs  If it fails to find such a connection, it sends  back an error message  0x40BSends back a message with name of the active Python script as task:<task_name> or the message no task!>


OperationPair that changes system resources:
[]

{}