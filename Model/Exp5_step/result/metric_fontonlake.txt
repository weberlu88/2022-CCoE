asg_object: ['/proc/\\.inl', '/tmp.*', '0x[0-9a-zA-Z]{1,16}', '^GID.*', '^PID.*', '^UID.*', '^dmesg$', '^insmod$', '^sh$']

Sample FontOnLake-eset.tech.csv
	num of segment in report: 76, 2 of them contain ASG object(s)
	lenght of ctd's OPset is 2
	#numofSTobject: 2, numofSTobject sysRrc: 0
	#R_malObj
	num of ctd objects: 3, num of asg objects: 22. R_malObj is 0.1364
		ctd_object: ['/proc/\\.inl', '/tmp.*']
	#R_malSysObj
	num of ctd objects: 0, num of asg objects: 0. R_malSysObj is 0.0000
		len(asg_OPset): 21, len(ctd_OPset): 2
	#R_malOps
	num of matched asg op: 0, num of asg op: 73. R_malOps is 0.0000
		refered lifecycle: []
	#R_malChangeOps
	num of matched asg op: 0, num of asg op: 1. R_malChangeOps is 0.0000
		ref-sys lifecycle: []

Sample FontOnLake-eset.wp.csv
	num of segment in report: 26, 11 of them contain ASG object(s)
	lenght of ctd's OPset is 39
	#numofSTobject: 9, numofSTobject sysRrc: 0
	#R_malObj
	num of ctd objects: 9, num of asg objects: 22. R_malObj is 0.4091
		ctd_object: ['/proc/\\.inl', '/tmp.*', '0x[0-9a-zA-Z]{1,16}', '^PID.*', '^UID.*']
	#R_malSysObj
	num of ctd objects: 0, num of asg objects: 0. R_malSysObj is 0.0000
		len(asg_OPset): 21, len(ctd_OPset): 39
	#R_malOps
	num of matched asg op: 20, num of asg op: 73. R_malOps is 0.2740
		refered lifecycle: [1, 2, 8, 12, 14, 18, 19, 20]
	#R_malChangeOps
	num of matched asg op: 1, num of asg op: 1. R_malChangeOps is 1.0000
		ref-sys lifecycle: [8]

	hits
	<OP 2 act=mprotect(), obj=0x[0-9a-zA-Z]{1,16} (mem)>, <OP16 act=receive, obj=0x409Uses, sent=release>|<uname.machine>|<ethernet_address> is sent  It also acquires all the credentials from the virtual file and sends them back one by one  Command structures Currently supported commands are described Table 7  Table 7 // Layer 1 commands of Backdoor 3 ID Description 0x100 Serves as a heartbeat and acquires all the credentials from the virtual file and sends them back one by one  0x101 Forwards the commands to the next layer   0x107 Exits  0x108 Closes all remote sessions and shells tied to a supplied unique ID   0x407 Forwards received data to a session tied to a supplied unique ID   0x408 Terminates Python script to be executed by the next command  0x409Uses a short Python script, which is presented in “Appendix 3”, to download and execute additional task – Python script   according to the extension from an FTP server protected with hardcoded credentials  The name of the file to be downloaded  is in the format tasks/<task_name>.py, where <task_name> is received  Only one such script can run at a time  Table 8 // Layer 2 commands of Backdoor 3 ID Description 0x300Executes supplied shell command and mediates subsequent I/O, each executed command is identified with a supplied  unique ID   If there is already one shell for the supplied unique ID, message hostid already connected  is sent back  0x301 Removes and terminates a shell session for a supplied unique ID   0x302Forwards a message to certain shell session based on supplied unique ID   If it failed to find such shell session, message no  find shell hostid!>
	<OP 3 act=arch_prctl(), obj=0x[0-9a-zA-Z]{1,16} (mem)>, <OP16 act=receive, obj=0x409Uses, sent=release>|<uname.machine>|<ethernet_address> is sent  It also acquires all the credentials from the virtual file and sends them back one by one  Command structures Currently supported commands are described Table 7  Table 7 // Layer 1 commands of Backdoor 3 ID Description 0x100 Serves as a heartbeat and acquires all the credentials from the virtual file and sends them back one by one  0x101 Forwards the commands to the next layer   0x107 Exits  0x108 Closes all remote sessions and shells tied to a supplied unique ID   0x407 Forwards received data to a session tied to a supplied unique ID   0x408 Terminates Python script to be executed by the next command  0x409Uses a short Python script, which is presented in “Appendix 3”, to download and execute additional task – Python script   according to the extension from an FTP server protected with hardcoded credentials  The name of the file to be downloaded  is in the format tasks/<task_name>.py, where <task_name> is received  Only one such script can run at a time  Table 8 // Layer 2 commands of Backdoor 3 ID Description 0x300Executes supplied shell command and mediates subsequent I/O, each executed command is identified with a supplied  unique ID   If there is already one shell for the supplied unique ID, message hostid already connected  is sent back  0x301 Removes and terminates a shell session for a supplied unique ID   0x302Forwards a message to certain shell session based on supplied unique ID   If it failed to find such shell session, message no  find shell hostid!>
	<OP 9 act=write(), obj=/tmp.*>, <OP 1 act=write, obj=/tmp/.tmp_<random>, sent= . . . . . . . . . . . . . . . . . 23 C&Cs . . . . . . . . . . . . . . . . . . . . 24 Filenames . . . . . . . . . . . . . . . . . . 24 Virtual filenames . . . . . . . . . . . . . . . . 24 MITRE ATT&CK techniques . . . . . . . . . . . . . . 25 Appendix 1 . . . . . . . . . . . . . . . . . . . 26 Appendix 2 . . . . . . . . . . . . . . . . . . . 26 Appendix 3 . . . . . . . . . . . . . . . . . . . 28  EXECUTIVE SUMMARY  FontOnLake is a malware family utilizing well-designed custom modules that are constantly under  development  It targets systems running Linux and provides remote access to those systems for its  operators, collects credentials, and serves as a proxy server   Its presence is always accompanied by a  rootkit, which conceals its existence  Their sneaky nature and advanced design suggest that these tools are used in targeted attacks; the  location of the C&C server and the countries from which the samples were uploaded to VirusTotal might  indicate that its operators target at least Southeast Asia  We believe that its operators are overly cautious since almost all samples seen use different, unique C&C  servers with varying non-standard ports  The authors use mostly C/C++ and various third-party libraries  such as Boost, Poco and Protobuf  None of the C&C servers used in samples uploaded to VirusTotal were  active at the time of writing, indicating that they could have been disabled due to the upload  We  conducted several internet-wide scans that imitated initial communication of its network protocols  targeting the observed non-standard ports in order to identify C&C servers and victims  We managed  to find only one active C&C server, which mostly just maintained connectivity via custom heartbeat  commands and did not provide any updates on explicit requests  The first known FontOnLake file appeared on VirusTotal in May 2020 and other samples were uploaded  throughout the year   Following our discovery while finalizing this white paper, vendors such as Tencent Security Response  Center, Avast and Lacework Labs published their research on what appears to be the same malware  TECHNICAL ANAL YSIS FontOnLake’s currently known components can be divided into the following three groups that interact  with each other: • Trojanized applications – otherwise legitimate binaries that are altered to load further components,  collect data, or conduct other malicious activities  • Backdoors – user-mode components serving as the main point of communication for its operators  • Rootkits – kernel-mode components that mostly hide and disguise their presence, assist with updates,  or provide fallback backdoors   TROJANIZED APPLICATIONS  Multiple trojanized applications were discovered; they are used mostly to load custom backdoor or  rootkit modules  Patches of the applications are most likely applied at the source code level, which  indicates that the applications must have been compiled and replaced the original ones  Aside from that, they can also collect sensitive data by modifying sensitive functions such as auth_ password in sshd  All the trojanized files are standard Linux utilities and serve as a persistence method because they are  commonly executed on system start-up  The initial way in which these applications get to the victims is not known  Interaction with the other components Communication of a trojanized application with its rootkit runs through a virtual file, which is created  and managed by the rootkit  Data can be read from or written to the virtual file and exported at the  operator’s request by its backdoor component  We will refer to the virtual file just as “the virtual file”  throughout this text (known names of the virtual file are in the “IoCs” section)  Interactions between FontOnLake components are visualized in Figure 1  Figure 1 // Interactions among the components Intercepting credentials in sshd Intercepting credentials in sshd is achieved through a modification of the auth_password function,  as seen in Figure 2, so that it will call the function seen in Figure 3  The credentials are written into the  virtual file in the form: sshd||<username>|<password> The version of sshd is 5 3p1  Figure 2 // Hex-Rays decompilation of the modified auth_password function in sshd Figure 3 // Hex-Rays decompilation of the function that collects sshd  credentials  BACKDOORS  We discovered three different backdoors; they are written in C++ and all use, albeit in slightly different  ways, the same Asio library from Boost for asynchronous network and low-level I/O   The functionality that they all have in common is that each exfiltrates collected sshd credentials and  bash command history to its C&C  Considering some of the overlapping functionality, most likely these  different backdoors are not used together on one compromised system  All the backdoors additionally use custom heartbeat commands sent and received periodically to keep  their C&C connections alive  FontOnLake malware uses filenames in the form /tmp/.tmp_<random>  Such on-disk files can be  hidden by the rootkits  All samples contained runtime type information (RTTI), and we could have used  several original names in the description  Backdoor 1 This is the simplest of the three FontOnLake backdoors; its overall functionality consists currently  (it appears that the malware is under development so features are likely to be added) of launching  and mediating access to a local SSH server, updating itself, and sending to the C&C server the stolen  credentials (for example by the aforementioned trojanized sshd)  Backdoor 1 is the only one that contains debug symbols; hence we can use all the original names in its  description  The main class of the backdoor is rmgr_client and its name reappears throughout the code  The  constructor of the class connects to the C&C and subsequently accepts commands described in the “List  of commands” section  We also have seen another sample of this backdoor with slight differences, which most notably  downloads an updated version of what is, most likely, a trojanized scp, among other applications known  to be trojanized  This “update” of scp suggests that there are trojanized applications that we could not obtain  Getting system info Backdoor 1 acquires system info by directly executing a Python script whose output is parsed into three  distinct variables, as seen in Figure 4  Figure 4 // Hex-Rays decompilation of the command acquirng system info If the command fails, FontOnLake assumes Python is not installed and triggers its installation (through  yum or apt-get)   List of commands  Currently supported commands in Backdoor 1 are described in Table 1  Table 1 // Overview of commands supported by Backdoor 1 CMD Behavior 0x10002 NOP – might be reserved for the injection functionality  0x10004 Exfiltrates credentials, one by one, by acquiring them from the rootkit and subsequently sending them  0x10006Finishes file-download and checks correctness of the downloaded file by calculating its CRC-32 and comparing  to the previously received CRC-32  0x10007 Downloads a part of file; appends body of the message onto already or just opened supplied file  0x10008Passes a message to a sshd session; body of the message is forwarded into the sshd  session  The session is  looked up by supplied ID in a map of sessions  0x1000ACreates a new sshd session; it connects to 127.0.0.1:26657   The session is inserted into the session map with  the supplied session ID   The implementation details are described in the “sshd_client” section  0x1000B Terminates a sshd session based on supplied session ID and removes it from the sshd  session map  0x1000F Starts update, described in the “Update mechanism” section  0x10010Kills a custom sshd  if running and terminates itself by instructing the rootkit to terminate it and remove its  on-disk file 0x10011 Extracts and executes the custom sshd, which is described in the “Custom sshd” section 0x10012 Kills the custom sshd if running Table 2 provides an overview of responses to received commands and initial messages  Table 2 // Overview of messages that can be sent by Backdoor 1 CMD Behavior 0x10001 Sends initial message for standard execution; it is sent at the beginning of the communication  0x10003 Sends heartbeat  0x10005Sends initial message for requesting updates; it supplies the CRC-32 of the file to be updated and the body of the  message contains the name of the component  0x10009 Forwards output of a sshd  session; supplies the ID of the session  0x1000C Confirms creation of a new sshd  session  0x1000D Confirms termination of an sshd  session  0x1000E Exfiltrates a credential   Custom sshd  After it is loaded by Backdoor 1, the custom sshd loads a hardcoded, embedded configuration instead of  loading one from a file, in comparison to the genuine sshd, which means that the on-disk configurations  are always overridden by its embedded one  The config most notably directs sshd to do the following: • Change the ListenAddress option to localhost, which means that this sshd is not meant to accept  remote connections  It is supposed to accept local connections mediated through the backdoor   • Permit root logins  • Enable X11 forwarding, which allows forwarding the application display of remotely started  applications  Also its auth_password function has been changed to always succeed, which is not such a problem on  a local network  Note that the full config is in “Appendix 1”, and this is the only trojanized application  dropped directly by one of the backdoors  The others can be downloaded during the backdoor’s update,  but the initial process of their installation is not known  It uses a hardcoded RSA private key instead of loading one from a key file  The use of this custom sshd  enables the attackers to hide their own sshd connections while keeping  the legitimate ones visible – thereby staying under the radar   It also does not have to add its keys to the  key file, thus avoiding making them visible to the victim  Update mechanism To download updates, Backdoor 1 executes its command handling functions (rmgr_client instances)  again with one difference – it connects to the C&C on a different port and changes the initial message   The initial message is not empty; this time it contains the CRC-32 of the file to be updated and the name  of the component (on_connect_message)  We expect updates to be acquired via commands 0x10007 and 0x10006 for downloading files, as  described in Table 1  Updates are described in the following table  We will refer to all generated  temporary filenames as temp; they are 32 bytes long and in format /tmp/.tmp_<random>  Table 3 // Overview of updates Component name on_connect_message new_path Additional info rmgr_client rmgr tempAdditionally, issues a command to  the rootkit, which terminates and  removes the previous version and  starts the new one  sshdsystem_type_system_ver_ sshd/usr/sbin/sshd ssh system_type_system_ver_ssh /usr/sbin/ssh inject.so inject.so temp rootkit system_type_kernel_ver.ko/lib/modules/kernel_ver/ kernel/drivers/input/misc/ ati_remote3.koAdditionally, instructs the rootkit  to update the list of files to be  hidden  Persistence script ati_remote3 modules/etc/sysconfig/modules/ ati_remote3.modulesOnly if the underlying system is  CentOS  Figure 5 summarizes the mechanism for downloading updates from the C&C  Figure 5 // Mechanism for downloading updates Implementation details In this section we describe the class structure of Backdoor 1 and mention some of the underlying design  patterns  session session is an abstract class that serves as a base for processing asynchronous I/O using boost::asio::io_ context  Its subclasses are required to implement a primitive operation, which is a part of the template  method for establishing the connection  Sending messages is conducted with boost::asio::async_write  Messages are not sent immediately but  rather are added to a queue  If the queue is empty, it raises an event that starts processing all the  pending messages – other messages could have been added before the event completes processing  Timers It additionally manages timers, which terminate the event processing loop on timeout  The timers  are set to 30 seconds and represent connect and receive timeouts; they are naturally terminated or  extended on the respective events  Its constructor requires a target port and host to be supplied; it  subsequently connects to it via boost::asio::async_connect  Object pool pattern session covers the format of exchanged messages as well  Allocation of these messages is managed by a  method representing an object pool pattern that reuses already existing but unused objects in respective  function templates  They are implemented with a queue holding unused objects, which are pushed back  when a message is sent, and popped on allocation, if it is non-empty  This use of an object pool suggests that an enormous number of these messages might be exchanged –  because X11 forwarding is going to be explicitly enabled in sshd and X11 is also known to be inefficient, it  might be one of the reasons for a possibly significant amount of traffic  Exchanged messages are represented by base class buffer, which holds a structure of the following type  (it can be transported directly using session): struct buffer_impl {  char data[0x100C];  uint32_t unknown;  uint64_t size;  uint64_t data_ptr; }; rmgr_client This class is derived from session  Exchanged messages are represented by the class message, which is an extension to buffer in the following  format: struct message_impl {  buffer_impl buffer;  uint64_t body_length;  uint32_t cmd;  uint32_t opt_parameter; }; Note that the body of message cannot carry more than 0x1000 bytes at once and it is always encoded/ decoded using buffer  The primitive operation for the connection template method of session initializes an asynchronous  reading loop with boost::asio::async_read, which receives and processes commands described in the “List  of commands” section  It also sends an initial message, which is empty by default  Receiving commands is done in two steps – in the first one body_length, cmd and opt_parameter are  received, while the second one gets the body of the message in size of body_length  sshd_client This class is also derived from session  It serves as a class for mediating I/O between a sshd process and another party  The primitive operation for the connection template method of session initializes an asynchronous  reading loop with boost::asio::async_read_some  In comparison with the async_read above, it is triggered  whenever any data is read – it does not want to wait until sshd outputs a certain number of bytes  The data read is passed to a callback function that must be supplied to the constructor   This selection of  algorithm at run time fits into the description of a strategy pattern that enables an algorithm’s behavior  to be selected at runtime  sshd_client is initialized only by rmgr_client, which wraps the read data into message and sends them  to the C&C  Shared library injection A timer, which currently does not do anything except reset itself, is set up  The timer contains a callback  whose symbol name is doInject; however, it is empty  There are also other functions that seem  to be intended for future shared library injection  Particularly the functions doLibsToRemove and  doLibsToAdd: they allow adding and removing one DT _NEEDED library of a file at a time by using a  modified patchelf library that accepts the name of the target file and the name of the library to be either  added to/removed from declared dependencies on dynamic libraries (DT _NEEDED)  Backdoor 2 The second backdoor serves most notably as a proxy and enables access to a customized sshd similar  to Backdoor 1  It also provides means for standard file manipulation, directory listing, uploading/ downloading files and updating itself, which are not present Backdoor 1  Exporting credentials is the  same as in Backdoor 1  Dynamic resolution of C&C To dynamically adjust the IP address and port and partially evade blacklisting, the C&C to be connected  to is acquired dynamically via an HTTP request from a first layer server   The backdoor randomly chooses a domain from a list, which is present in the “IoCs” section  It resolves  the domain and sends an HTTP GET request to the acquired IP on a non-standard port for URL path  / iplist  The response is base64 decoded, decrypted by AES-128-CBC with key M4InzQpqqC18d1KL   and IV T4kP7mzlYR8DaLU3  The decrypted response is a host in format <ip>:<port> and connected to  later   The HTTP request is implemented using Poco::Net and crypto using Poco::Crypto  Version The constructor of its main class, which is called Backdoor throughout the code, contains a string that  appears to be a version number v6.0.3  This probably indicates that the project has been undergoing  active development  We have also found a sample with version number v6.0.2 and minor differences such as using a single  domain instead of a domain list to query the host  Initialization of communication The backdoor changes the default encryption key to a random one using  Poco::UUIDGenerator::reateRandom()  It is afterwards sent with system info nodeId:<ethernet_address>|nodeName:<uname>
	<OP13 act=getuid(), obj=^UID.*>, <OP29 act=get, obj=UID, sent=inject.so inject.so overrides system calls execve, fork and bash to conceal output of the ss tool and log bash   history  It unsets environment variable LD_PRELOAD to block attempts to use the LD_PRELOAD trick on the  executable running this library  It checks whether the file it runs under is /bin/bash whose command line is -bash, i e , the default  shell or /usr/bin/ss  In such cases, it hooks fork – executes the original fork acquired by dlsym with  RTLD_DEFAULT and unsets the indicators that it runs under bash or ss in the child process, but they can  be still set later   If it runs under ss, it hooks execve; the hook calls the original execve with output filtered through  pipes, searches for its non-standard ports, and discards them from the output  If it runs under bash, function bash_add_history, whose address is acquired by dlsym with RTLD_ DEFAULT, default library search order, is hooked using the subhook library  The hook calls the real bash_ add_history and acquires symbol current_user using dlsym with RTLD_DEFAULT  The symbol is  used to get UID <bash_uid> and GUID <bash_guid> present in bash in the current_user structure  and writes |1|<time_since_epoch>|<ppid>|<pid>|<sid>|<bash_uid>|<bash_gid>|<history_ entry> to the virtual file  The rootkit generates a random name following its filename pattern, notes the file-path and writes the  embedded file to the location  It also sets permissions of the file to 755  It has no other use currently; it  is apparently under development  Empty  alloc_pid hook The rootkit uses method register_kretprobe to register kretprobe for alloc_pid symbol_name; it  does not register any handler and it does not seem to use it anywhere in the code, which suggests that  it might be some functionality in development  It is most likely going to be used with the shared library injection functionality somehow  Termination of hidden processes When one of the hidden processes is to be terminated, it needs to remove its PID from the list of PIDs to  be hidden  This is achieved by using method register_kprobe to register kprobe for do_exit symbol_name:  it registers a pre_handler that checks whether the PID of process to exit is present in the list of PIDs  to be hidden  In that case, it removes the PID from the list  Additionally, if the PID belongs to the main  backdoor, it sets a variable indicating that there is no main backdoor – it is required to enable an  updated one to register itself  Hiding memory regions To hide memory regions mapped from its files, the rootkit uses method register_kretprobe to  register kretprobe for seq_path symbol_name, it registers both handler and entry_handler and sets  data_size to 8: • entry_handler – instructs kernel threads to be skipped: a kernel thread is recognized by checking  whether mm structure of the current task_struct is a null pointer   It also moves the DI register, which  is the first parameter – seq_file, to the kretprobe_instance data  • handler – instructs kernel threads to be skipped in the same way as before  If the last entry contains  the substring /tmp/.tmp_, it trims it, which effectively hides the presence of memory-mapped  regions, unless the PID of the caller belongs to the main backdoor   It seems that this technique has not been documented yet  The method seq_path is used especially  by show_map, which lists memory regions in /proc/<PID>/maps  It is most likely supposed to hide its  libraries that are injected to other, legitimate processes  Figure 11 // Hex-Rays decompilation of the seq_path handler Hiding processes and files The rootkit overrides the system call getdents to hide certain processes and files as in the previous  version  In comparison to the other version, it hides more files – the rootkit and those following its  filename format (/tmp/.tmp_<random>) that weren’t present on-disk in the other version  The main modifications are in filldir, which is used by getdents: it skips further processing and  returns to hide the target file if it is: • under /proc and is the virtual file or present in the list of the PIDs to be hidden  • under /tmp, begins with .tmp_ and the PID of the caller does not belong to the main backdoor   • /lib/modules/kernel_ver/kernel/drivers/input/misc/ati_remote3.ko or /etc/ sysconfig/modules/ati_remote3.modules  Hiding network connections The rootkit hooks tcp4_seq_show() seq_operation in the same way as in the other version to hide its  network connections  Hiding itself (its own kernel module) seq_show() seq_operation of /proc/modules is hooked by the rootkit to hide itself from the list  This  is achieved by calling the original one and checking the result for ati_remote3.ko; if it is found, the  last entry is discarded – it is not known what the reason for this is, since the next step would hide it  from the output of /proc/modules implicitly  It also unlinks its kobject via the kobject_del() method, which will hide it from the lsmod command  executed as root as well  Update mechanism To update, the rootkit terminates the main running backdoor and removes its on-disk file; it  subsequently copies the updated version downloaded by the backdoor to the original location, sets its  permissions to 755, and executes it with command line [khelper]   If the process fails for whatever reason, it generates a random name following its filename format,  writes the original embedded backdoor to the file and executes it in the same way  CONCLUSION We have found and described a set of malicious and at the time of discovery unknown tools which do  not seem to belong to any recognized malware family  Their scale and advanced design suggest that the  authors are well versed in cybersecurity and that these tools might be reused in future campaigns  As most of the features are designed just to hide its presence, relay communication, and provide  backdoor access, we believe that these tools are used mostly to maintain an infrastructure which serves  some other, unknown, malicious purposes  In the past we described an operation that shared certain behavioral patterns; similarly, it collected  sshd credentials to compromise further machines, built its infrastructure out of afflicted servers and  injected a dynamic library using DT _NEEDED into processes, which hooked execve as well  However, its  scale and impact were much greater   If interested, you can read about Operation Windigo in this white  paper and this follow-up blogpost   IOCS   Samples  SHA-1 Description Detection name 1F52DB8E3FC3040C017928F5FFD99D9FA4757BF8 Trojanized cat Linux/FontOnLake771340752985DD8E84CF3843C9843EF7A76A39E7 Trojanized kill 27E868C0505144F0708170DF701D7C1AE8E1FAEA Trojanized sftp 45E94ABEDAD8C0044A43FF6D72A5C44C6ABD9378 Trojanized sshd 1829B0E34807765F2B254EA5514D7BB587AECA3F Custom sshd 8D6ACA824D1A717AE908669E356E2D4BB6F857B0 Custom sshd 38B09D690FAFE81E964CBD45EC7CF20DCB296B4D Backdoor 1 56556A53741111C04853A5E84744807EEADFF63A Backdoor 1 FE26CB98AA1416A8B1F6CED4AC1B5400517257B2 Backdoor 1 D4E0E38EC69CBB71475D8A22EDB428C3E955A5EA Backdoor 1 204046B3279B487863738DDB17CBB6718AF2A83A Backdoor 2 9C803D1E39F335F213F367A84D3DF6150E5FE172 Backdoor 2 BFCC4E6628B63C92BC46219937EA7582EA6FBB41 Backdoor 2 515CFB5CB760D3A1DA31E9F906EA7F84F17C5136 Backdoor 3 A9ED0837E3AF698906B229CA28B988010BCD5DC1 Backdoor 3 56CB85675FE7A7896F0AA5365FF391AC376D9953 Rootkit version 1 72C9C5CE50A38D0A2B9CEF6ADEAB1008BFF12496 Rootkit version 1 B439A503D68AD7164E0F32B03243A593312040F8 Rootkit version 1 E7BF0A35C2CD79A658615E312D35BBCFF9782672 Rootkit version 1 56580E7BA6BF26D878C538985A6DC62CA094CD04 Rootkit version 1 49D4E5FCD3A3018A88F329AE47EF4C87C6A2D27A Rootkit version 1 74D44C2949DA7D5164ADEC78801733680DA8C110 Rootkit version 2 74D755E8566340A752B1DB603EF468253ADAB6BD Rootkit version 2 E20F87497023E3454B5B1A22FE6C5A5501EAE2CB Rootkit version 2 6F43C598CD9E63F550FF4E6EF51500E47D0211F3 inject.so C&Cs From samples: 47.107.60.212 47.112.197.119 156.238.111.174 172.96.231.69 hm2.yrnykx.com ywbgrcrupasdiqxknwgceatlnbvmezti.com yhgrffndvzbtoilmundkmvbaxrjtqsew.com wcmbqxzeuopnvyfmhkstaretfciywdrl.name ruciplbrxwjscyhtapvlfskoqqgnxevw.name pdjwebrfgdyzljmwtxcoyomapxtzchvn.com nfcomizsdseqiomzqrxwvtprxbljkpgd.name hkxpqdtgsucylodaejmzmtnkpfvojabe.com etzndtcvqvyxajpcgwkzsoweaubilflh.com esnoptdkkiirzewlpgmccbwuynvxjumf.name ekubhtlgnjndrmjbsqitdvvewcgzpacy.name From internet-wide scan: 27.102.130.63 Filenames /lib/modules/<VARIABLE>/kernel/drivers/input/misc/ati_remote3.ko /etc/sysconfig/modules/ati_remote3.modules /tmp/.tmp_<RANDOM> Virtual filenames /proc/.dot3 /proc/.inl MITRE ATT&CK TECHNIQUES This table was built using version 9 of the ATT&CK framework>
	<OP15 act=geteuid(), obj=^UID.*>, <OP29 act=get, obj=UID, sent=inject.so inject.so overrides system calls execve, fork and bash to conceal output of the ss tool and log bash   history  It unsets environment variable LD_PRELOAD to block attempts to use the LD_PRELOAD trick on the  executable running this library  It checks whether the file it runs under is /bin/bash whose command line is -bash, i e , the default  shell or /usr/bin/ss  In such cases, it hooks fork – executes the original fork acquired by dlsym with  RTLD_DEFAULT and unsets the indicators that it runs under bash or ss in the child process, but they can  be still set later   If it runs under ss, it hooks execve; the hook calls the original execve with output filtered through  pipes, searches for its non-standard ports, and discards them from the output  If it runs under bash, function bash_add_history, whose address is acquired by dlsym with RTLD_ DEFAULT, default library search order, is hooked using the subhook library  The hook calls the real bash_ add_history and acquires symbol current_user using dlsym with RTLD_DEFAULT  The symbol is  used to get UID <bash_uid> and GUID <bash_guid> present in bash in the current_user structure  and writes |1|<time_since_epoch>|<ppid>|<pid>|<sid>|<bash_uid>|<bash_gid>|<history_ entry> to the virtual file  The rootkit generates a random name following its filename pattern, notes the file-path and writes the  embedded file to the location  It also sets permissions of the file to 755  It has no other use currently; it  is apparently under development  Empty  alloc_pid hook The rootkit uses method register_kretprobe to register kretprobe for alloc_pid symbol_name; it  does not register any handler and it does not seem to use it anywhere in the code, which suggests that  it might be some functionality in development  It is most likely going to be used with the shared library injection functionality somehow  Termination of hidden processes When one of the hidden processes is to be terminated, it needs to remove its PID from the list of PIDs to  be hidden  This is achieved by using method register_kprobe to register kprobe for do_exit symbol_name:  it registers a pre_handler that checks whether the PID of process to exit is present in the list of PIDs  to be hidden  In that case, it removes the PID from the list  Additionally, if the PID belongs to the main  backdoor, it sets a variable indicating that there is no main backdoor – it is required to enable an  updated one to register itself  Hiding memory regions To hide memory regions mapped from its files, the rootkit uses method register_kretprobe to  register kretprobe for seq_path symbol_name, it registers both handler and entry_handler and sets  data_size to 8: • entry_handler – instructs kernel threads to be skipped: a kernel thread is recognized by checking  whether mm structure of the current task_struct is a null pointer   It also moves the DI register, which  is the first parameter – seq_file, to the kretprobe_instance data  • handler – instructs kernel threads to be skipped in the same way as before  If the last entry contains  the substring /tmp/.tmp_, it trims it, which effectively hides the presence of memory-mapped  regions, unless the PID of the caller belongs to the main backdoor   It seems that this technique has not been documented yet  The method seq_path is used especially  by show_map, which lists memory regions in /proc/<PID>/maps  It is most likely supposed to hide its  libraries that are injected to other, legitimate processes  Figure 11 // Hex-Rays decompilation of the seq_path handler Hiding processes and files The rootkit overrides the system call getdents to hide certain processes and files as in the previous  version  In comparison to the other version, it hides more files – the rootkit and those following its  filename format (/tmp/.tmp_<random>) that weren’t present on-disk in the other version  The main modifications are in filldir, which is used by getdents: it skips further processing and  returns to hide the target file if it is: • under /proc and is the virtual file or present in the list of the PIDs to be hidden  • under /tmp, begins with .tmp_ and the PID of the caller does not belong to the main backdoor   • /lib/modules/kernel_ver/kernel/drivers/input/misc/ati_remote3.ko or /etc/ sysconfig/modules/ati_remote3.modules  Hiding network connections The rootkit hooks tcp4_seq_show() seq_operation in the same way as in the other version to hide its  network connections  Hiding itself (its own kernel module) seq_show() seq_operation of /proc/modules is hooked by the rootkit to hide itself from the list  This  is achieved by calling the original one and checking the result for ati_remote3.ko; if it is found, the  last entry is discarded – it is not known what the reason for this is, since the next step would hide it  from the output of /proc/modules implicitly  It also unlinks its kobject via the kobject_del() method, which will hide it from the lsmod command  executed as root as well  Update mechanism To update, the rootkit terminates the main running backdoor and removes its on-disk file; it  subsequently copies the updated version downloaded by the backdoor to the original location, sets its  permissions to 755, and executes it with command line [khelper]   If the process fails for whatever reason, it generates a random name following its filename format,  writes the original embedded backdoor to the file and executes it in the same way  CONCLUSION We have found and described a set of malicious and at the time of discovery unknown tools which do  not seem to belong to any recognized malware family  Their scale and advanced design suggest that the  authors are well versed in cybersecurity and that these tools might be reused in future campaigns  As most of the features are designed just to hide its presence, relay communication, and provide  backdoor access, we believe that these tools are used mostly to maintain an infrastructure which serves  some other, unknown, malicious purposes  In the past we described an operation that shared certain behavioral patterns; similarly, it collected  sshd credentials to compromise further machines, built its infrastructure out of afflicted servers and  injected a dynamic library using DT _NEEDED into processes, which hooked execve as well  However, its  scale and impact were much greater   If interested, you can read about Operation Windigo in this white  paper and this follow-up blogpost   IOCS   Samples  SHA-1 Description Detection name 1F52DB8E3FC3040C017928F5FFD99D9FA4757BF8 Trojanized cat Linux/FontOnLake771340752985DD8E84CF3843C9843EF7A76A39E7 Trojanized kill 27E868C0505144F0708170DF701D7C1AE8E1FAEA Trojanized sftp 45E94ABEDAD8C0044A43FF6D72A5C44C6ABD9378 Trojanized sshd 1829B0E34807765F2B254EA5514D7BB587AECA3F Custom sshd 8D6ACA824D1A717AE908669E356E2D4BB6F857B0 Custom sshd 38B09D690FAFE81E964CBD45EC7CF20DCB296B4D Backdoor 1 56556A53741111C04853A5E84744807EEADFF63A Backdoor 1 FE26CB98AA1416A8B1F6CED4AC1B5400517257B2 Backdoor 1 D4E0E38EC69CBB71475D8A22EDB428C3E955A5EA Backdoor 1 204046B3279B487863738DDB17CBB6718AF2A83A Backdoor 2 9C803D1E39F335F213F367A84D3DF6150E5FE172 Backdoor 2 BFCC4E6628B63C92BC46219937EA7582EA6FBB41 Backdoor 2 515CFB5CB760D3A1DA31E9F906EA7F84F17C5136 Backdoor 3 A9ED0837E3AF698906B229CA28B988010BCD5DC1 Backdoor 3 56CB85675FE7A7896F0AA5365FF391AC376D9953 Rootkit version 1 72C9C5CE50A38D0A2B9CEF6ADEAB1008BFF12496 Rootkit version 1 B439A503D68AD7164E0F32B03243A593312040F8 Rootkit version 1 E7BF0A35C2CD79A658615E312D35BBCFF9782672 Rootkit version 1 56580E7BA6BF26D878C538985A6DC62CA094CD04 Rootkit version 1 49D4E5FCD3A3018A88F329AE47EF4C87C6A2D27A Rootkit version 1 74D44C2949DA7D5164ADEC78801733680DA8C110 Rootkit version 2 74D755E8566340A752B1DB603EF468253ADAB6BD Rootkit version 2 E20F87497023E3454B5B1A22FE6C5A5501EAE2CB Rootkit version 2 6F43C598CD9E63F550FF4E6EF51500E47D0211F3 inject.so C&Cs From samples: 47.107.60.212 47.112.197.119 156.238.111.174 172.96.231.69 hm2.yrnykx.com ywbgrcrupasdiqxknwgceatlnbvmezti.com yhgrffndvzbtoilmundkmvbaxrjtqsew.com wcmbqxzeuopnvyfmhkstaretfciywdrl.name ruciplbrxwjscyhtapvlfskoqqgnxevw.name pdjwebrfgdyzljmwtxcoyomapxtzchvn.com nfcomizsdseqiomzqrxwvtprxbljkpgd.name hkxpqdtgsucylodaejmzmtnkpfvojabe.com etzndtcvqvyxajpcgwkzsoweaubilflh.com esnoptdkkiirzewlpgmccbwuynvxjumf.name ekubhtlgnjndrmjbsqitdvvewcgzpacy.name From internet-wide scan: 27.102.130.63 Filenames /lib/modules/<VARIABLE>/kernel/drivers/input/misc/ati_remote3.ko /etc/sysconfig/modules/ati_remote3.modules /tmp/.tmp_<RANDOM> Virtual filenames /proc/.dot3 /proc/.inl MITRE ATT&CK TECHNIQUES This table was built using version 9 of the ATT&CK framework>
	<OP19 act=set_tid_address(), obj=0x[0-9a-zA-Z]{1,16} (mem)>, <OP16 act=receive, obj=0x409Uses, sent=release>|<uname.machine>|<ethernet_address> is sent  It also acquires all the credentials from the virtual file and sends them back one by one  Command structures Currently supported commands are described Table 7  Table 7 // Layer 1 commands of Backdoor 3 ID Description 0x100 Serves as a heartbeat and acquires all the credentials from the virtual file and sends them back one by one  0x101 Forwards the commands to the next layer   0x107 Exits  0x108 Closes all remote sessions and shells tied to a supplied unique ID   0x407 Forwards received data to a session tied to a supplied unique ID   0x408 Terminates Python script to be executed by the next command  0x409Uses a short Python script, which is presented in “Appendix 3”, to download and execute additional task – Python script   according to the extension from an FTP server protected with hardcoded credentials  The name of the file to be downloaded  is in the format tasks/<task_name>.py, where <task_name> is received  Only one such script can run at a time  Table 8 // Layer 2 commands of Backdoor 3 ID Description 0x300Executes supplied shell command and mediates subsequent I/O, each executed command is identified with a supplied  unique ID   If there is already one shell for the supplied unique ID, message hostid already connected  is sent back  0x301 Removes and terminates a shell session for a supplied unique ID   0x302Forwards a message to certain shell session based on supplied unique ID   If it failed to find such shell session, message no  find shell hostid!>
	<OP20 act=set_robust_list(), obj=0x[0-9a-zA-Z]{1,16} (mem)>, <OP16 act=receive, obj=0x409Uses, sent=release>|<uname.machine>|<ethernet_address> is sent  It also acquires all the credentials from the virtual file and sends them back one by one  Command structures Currently supported commands are described Table 7  Table 7 // Layer 1 commands of Backdoor 3 ID Description 0x100 Serves as a heartbeat and acquires all the credentials from the virtual file and sends them back one by one  0x101 Forwards the commands to the next layer   0x107 Exits  0x108 Closes all remote sessions and shells tied to a supplied unique ID   0x407 Forwards received data to a session tied to a supplied unique ID   0x408 Terminates Python script to be executed by the next command  0x409Uses a short Python script, which is presented in “Appendix 3”, to download and execute additional task – Python script   according to the extension from an FTP server protected with hardcoded credentials  The name of the file to be downloaded  is in the format tasks/<task_name>.py, where <task_name> is received  Only one such script can run at a time  Table 8 // Layer 2 commands of Backdoor 3 ID Description 0x300Executes supplied shell command and mediates subsequent I/O, each executed command is identified with a supplied  unique ID   If there is already one shell for the supplied unique ID, message hostid already connected  is sent back  0x301 Removes and terminates a shell session for a supplied unique ID   0x302Forwards a message to certain shell session based on supplied unique ID   If it failed to find such shell session, message no  find shell hostid!>
	<OP21 act=futex(), obj=0x[0-9a-zA-Z]{1,16} (mem)>, <OP18 act=terminate, obj=0x302Forwards, sent=release>|<uname.machine>|<ethernet_address> is sent  It also acquires all the credentials from the virtual file and sends them back one by one  Command structures Currently supported commands are described Table 7  Table 7 // Layer 1 commands of Backdoor 3 ID Description 0x100 Serves as a heartbeat and acquires all the credentials from the virtual file and sends them back one by one  0x101 Forwards the commands to the next layer   0x107 Exits  0x108 Closes all remote sessions and shells tied to a supplied unique ID   0x407 Forwards received data to a session tied to a supplied unique ID   0x408 Terminates Python script to be executed by the next command  0x409Uses a short Python script, which is presented in “Appendix 3”, to download and execute additional task – Python script   according to the extension from an FTP server protected with hardcoded credentials  The name of the file to be downloaded  is in the format tasks/<task_name>.py, where <task_name> is received  Only one such script can run at a time  Table 8 // Layer 2 commands of Backdoor 3 ID Description 0x300Executes supplied shell command and mediates subsequent I/O, each executed command is identified with a supplied  unique ID   If there is already one shell for the supplied unique ID, message hostid already connected  is sent back  0x301 Removes and terminates a shell session for a supplied unique ID   0x302Forwards a message to certain shell session based on supplied unique ID   If it failed to find such shell session, message no  find shell hostid!>

	sys_hits
	<OP 9 act=write(), obj=/tmp.*>, <OP 1 act=write, obj=/tmp/.tmp_<random>, sent= . . . . . . . . . . . . . . . . . 23 C&Cs . . . . . . . . . . . . . . . . . . . . 24 Filenames . . . . . . . . . . . . . . . . . . 24 Virtual filenames . . . . . . . . . . . . . . . . 24 MITRE ATT&CK techniques . . . . . . . . . . . . . . 25 Appendix 1 . . . . . . . . . . . . . . . . . . . 26 Appendix 2 . . . . . . . . . . . . . . . . . . . 26 Appendix 3 . . . . . . . . . . . . . . . . . . . 28  EXECUTIVE SUMMARY  FontOnLake is a malware family utilizing well-designed custom modules that are constantly under  development  It targets systems running Linux and provides remote access to those systems for its  operators, collects credentials, and serves as a proxy server   Its presence is always accompanied by a  rootkit, which conceals its existence  Their sneaky nature and advanced design suggest that these tools are used in targeted attacks; the  location of the C&C server and the countries from which the samples were uploaded to VirusTotal might  indicate that its operators target at least Southeast Asia  We believe that its operators are overly cautious since almost all samples seen use different, unique C&C  servers with varying non-standard ports  The authors use mostly C/C++ and various third-party libraries  such as Boost, Poco and Protobuf  None of the C&C servers used in samples uploaded to VirusTotal were  active at the time of writing, indicating that they could have been disabled due to the upload  We  conducted several internet-wide scans that imitated initial communication of its network protocols  targeting the observed non-standard ports in order to identify C&C servers and victims  We managed  to find only one active C&C server, which mostly just maintained connectivity via custom heartbeat  commands and did not provide any updates on explicit requests  The first known FontOnLake file appeared on VirusTotal in May 2020 and other samples were uploaded  throughout the year   Following our discovery while finalizing this white paper, vendors such as Tencent Security Response  Center, Avast and Lacework Labs published their research on what appears to be the same malware  TECHNICAL ANAL YSIS FontOnLake’s currently known components can be divided into the following three groups that interact  with each other: • Trojanized applications – otherwise legitimate binaries that are altered to load further components,  collect data, or conduct other malicious activities  • Backdoors – user-mode components serving as the main point of communication for its operators  • Rootkits – kernel-mode components that mostly hide and disguise their presence, assist with updates,  or provide fallback backdoors   TROJANIZED APPLICATIONS  Multiple trojanized applications were discovered; they are used mostly to load custom backdoor or  rootkit modules  Patches of the applications are most likely applied at the source code level, which  indicates that the applications must have been compiled and replaced the original ones  Aside from that, they can also collect sensitive data by modifying sensitive functions such as auth_ password in sshd  All the trojanized files are standard Linux utilities and serve as a persistence method because they are  commonly executed on system start-up  The initial way in which these applications get to the victims is not known  Interaction with the other components Communication of a trojanized application with its rootkit runs through a virtual file, which is created  and managed by the rootkit  Data can be read from or written to the virtual file and exported at the  operator’s request by its backdoor component  We will refer to the virtual file just as “the virtual file”  throughout this text (known names of the virtual file are in the “IoCs” section)  Interactions between FontOnLake components are visualized in Figure 1  Figure 1 // Interactions among the components Intercepting credentials in sshd Intercepting credentials in sshd is achieved through a modification of the auth_password function,  as seen in Figure 2, so that it will call the function seen in Figure 3  The credentials are written into the  virtual file in the form: sshd||<username>|<password> The version of sshd is 5 3p1  Figure 2 // Hex-Rays decompilation of the modified auth_password function in sshd Figure 3 // Hex-Rays decompilation of the function that collects sshd  credentials  BACKDOORS  We discovered three different backdoors; they are written in C++ and all use, albeit in slightly different  ways, the same Asio library from Boost for asynchronous network and low-level I/O   The functionality that they all have in common is that each exfiltrates collected sshd credentials and  bash command history to its C&C  Considering some of the overlapping functionality, most likely these  different backdoors are not used together on one compromised system  All the backdoors additionally use custom heartbeat commands sent and received periodically to keep  their C&C connections alive  FontOnLake malware uses filenames in the form /tmp/.tmp_<random>  Such on-disk files can be  hidden by the rootkits  All samples contained runtime type information (RTTI), and we could have used  several original names in the description  Backdoor 1 This is the simplest of the three FontOnLake backdoors; its overall functionality consists currently  (it appears that the malware is under development so features are likely to be added) of launching  and mediating access to a local SSH server, updating itself, and sending to the C&C server the stolen  credentials (for example by the aforementioned trojanized sshd)  Backdoor 1 is the only one that contains debug symbols; hence we can use all the original names in its  description  The main class of the backdoor is rmgr_client and its name reappears throughout the code  The  constructor of the class connects to the C&C and subsequently accepts commands described in the “List  of commands” section  We also have seen another sample of this backdoor with slight differences, which most notably  downloads an updated version of what is, most likely, a trojanized scp, among other applications known  to be trojanized  This “update” of scp suggests that there are trojanized applications that we could not obtain  Getting system info Backdoor 1 acquires system info by directly executing a Python script whose output is parsed into three  distinct variables, as seen in Figure 4  Figure 4 // Hex-Rays decompilation of the command acquirng system info If the command fails, FontOnLake assumes Python is not installed and triggers its installation (through  yum or apt-get)   List of commands  Currently supported commands in Backdoor 1 are described in Table 1  Table 1 // Overview of commands supported by Backdoor 1 CMD Behavior 0x10002 NOP – might be reserved for the injection functionality  0x10004 Exfiltrates credentials, one by one, by acquiring them from the rootkit and subsequently sending them  0x10006Finishes file-download and checks correctness of the downloaded file by calculating its CRC-32 and comparing  to the previously received CRC-32  0x10007 Downloads a part of file; appends body of the message onto already or just opened supplied file  0x10008Passes a message to a sshd session; body of the message is forwarded into the sshd  session  The session is  looked up by supplied ID in a map of sessions  0x1000ACreates a new sshd session; it connects to 127.0.0.1:26657   The session is inserted into the session map with  the supplied session ID   The implementation details are described in the “sshd_client” section  0x1000B Terminates a sshd session based on supplied session ID and removes it from the sshd  session map  0x1000F Starts update, described in the “Update mechanism” section  0x10010Kills a custom sshd  if running and terminates itself by instructing the rootkit to terminate it and remove its  on-disk file 0x10011 Extracts and executes the custom sshd, which is described in the “Custom sshd” section 0x10012 Kills the custom sshd if running Table 2 provides an overview of responses to received commands and initial messages  Table 2 // Overview of messages that can be sent by Backdoor 1 CMD Behavior 0x10001 Sends initial message for standard execution; it is sent at the beginning of the communication  0x10003 Sends heartbeat  0x10005Sends initial message for requesting updates; it supplies the CRC-32 of the file to be updated and the body of the  message contains the name of the component  0x10009 Forwards output of a sshd  session; supplies the ID of the session  0x1000C Confirms creation of a new sshd  session  0x1000D Confirms termination of an sshd  session  0x1000E Exfiltrates a credential   Custom sshd  After it is loaded by Backdoor 1, the custom sshd loads a hardcoded, embedded configuration instead of  loading one from a file, in comparison to the genuine sshd, which means that the on-disk configurations  are always overridden by its embedded one  The config most notably directs sshd to do the following: • Change the ListenAddress option to localhost, which means that this sshd is not meant to accept  remote connections  It is supposed to accept local connections mediated through the backdoor   • Permit root logins  • Enable X11 forwarding, which allows forwarding the application display of remotely started  applications  Also its auth_password function has been changed to always succeed, which is not such a problem on  a local network  Note that the full config is in “Appendix 1”, and this is the only trojanized application  dropped directly by one of the backdoors  The others can be downloaded during the backdoor’s update,  but the initial process of their installation is not known  It uses a hardcoded RSA private key instead of loading one from a key file  The use of this custom sshd  enables the attackers to hide their own sshd connections while keeping  the legitimate ones visible – thereby staying under the radar   It also does not have to add its keys to the  key file, thus avoiding making them visible to the victim  Update mechanism To download updates, Backdoor 1 executes its command handling functions (rmgr_client instances)  again with one difference – it connects to the C&C on a different port and changes the initial message   The initial message is not empty; this time it contains the CRC-32 of the file to be updated and the name  of the component (on_connect_message)  We expect updates to be acquired via commands 0x10007 and 0x10006 for downloading files, as  described in Table 1  Updates are described in the following table  We will refer to all generated  temporary filenames as temp; they are 32 bytes long and in format /tmp/.tmp_<random>  Table 3 // Overview of updates Component name on_connect_message new_path Additional info rmgr_client rmgr tempAdditionally, issues a command to  the rootkit, which terminates and  removes the previous version and  starts the new one  sshdsystem_type_system_ver_ sshd/usr/sbin/sshd ssh system_type_system_ver_ssh /usr/sbin/ssh inject.so inject.so temp rootkit system_type_kernel_ver.ko/lib/modules/kernel_ver/ kernel/drivers/input/misc/ ati_remote3.koAdditionally, instructs the rootkit  to update the list of files to be  hidden  Persistence script ati_remote3 modules/etc/sysconfig/modules/ ati_remote3.modulesOnly if the underlying system is  CentOS  Figure 5 summarizes the mechanism for downloading updates from the C&C  Figure 5 // Mechanism for downloading updates Implementation details In this section we describe the class structure of Backdoor 1 and mention some of the underlying design  patterns  session session is an abstract class that serves as a base for processing asynchronous I/O using boost::asio::io_ context  Its subclasses are required to implement a primitive operation, which is a part of the template  method for establishing the connection  Sending messages is conducted with boost::asio::async_write  Messages are not sent immediately but  rather are added to a queue  If the queue is empty, it raises an event that starts processing all the  pending messages – other messages could have been added before the event completes processing  Timers It additionally manages timers, which terminate the event processing loop on timeout  The timers  are set to 30 seconds and represent connect and receive timeouts; they are naturally terminated or  extended on the respective events  Its constructor requires a target port and host to be supplied; it  subsequently connects to it via boost::asio::async_connect  Object pool pattern session covers the format of exchanged messages as well  Allocation of these messages is managed by a  method representing an object pool pattern that reuses already existing but unused objects in respective  function templates  They are implemented with a queue holding unused objects, which are pushed back  when a message is sent, and popped on allocation, if it is non-empty  This use of an object pool suggests that an enormous number of these messages might be exchanged –  because X11 forwarding is going to be explicitly enabled in sshd and X11 is also known to be inefficient, it  might be one of the reasons for a possibly significant amount of traffic  Exchanged messages are represented by base class buffer, which holds a structure of the following type  (it can be transported directly using session): struct buffer_impl {  char data[0x100C];  uint32_t unknown;  uint64_t size;  uint64_t data_ptr; }; rmgr_client This class is derived from session  Exchanged messages are represented by the class message, which is an extension to buffer in the following  format: struct message_impl {  buffer_impl buffer;  uint64_t body_length;  uint32_t cmd;  uint32_t opt_parameter; }; Note that the body of message cannot carry more than 0x1000 bytes at once and it is always encoded/ decoded using buffer  The primitive operation for the connection template method of session initializes an asynchronous  reading loop with boost::asio::async_read, which receives and processes commands described in the “List  of commands” section  It also sends an initial message, which is empty by default  Receiving commands is done in two steps – in the first one body_length, cmd and opt_parameter are  received, while the second one gets the body of the message in size of body_length  sshd_client This class is also derived from session  It serves as a class for mediating I/O between a sshd process and another party  The primitive operation for the connection template method of session initializes an asynchronous  reading loop with boost::asio::async_read_some  In comparison with the async_read above, it is triggered  whenever any data is read – it does not want to wait until sshd outputs a certain number of bytes  The data read is passed to a callback function that must be supplied to the constructor   This selection of  algorithm at run time fits into the description of a strategy pattern that enables an algorithm’s behavior  to be selected at runtime  sshd_client is initialized only by rmgr_client, which wraps the read data into message and sends them  to the C&C  Shared library injection A timer, which currently does not do anything except reset itself, is set up  The timer contains a callback  whose symbol name is doInject; however, it is empty  There are also other functions that seem  to be intended for future shared library injection  Particularly the functions doLibsToRemove and  doLibsToAdd: they allow adding and removing one DT _NEEDED library of a file at a time by using a  modified patchelf library that accepts the name of the target file and the name of the library to be either  added to/removed from declared dependencies on dynamic libraries (DT _NEEDED)  Backdoor 2 The second backdoor serves most notably as a proxy and enables access to a customized sshd similar  to Backdoor 1  It also provides means for standard file manipulation, directory listing, uploading/ downloading files and updating itself, which are not present Backdoor 1  Exporting credentials is the  same as in Backdoor 1  Dynamic resolution of C&C To dynamically adjust the IP address and port and partially evade blacklisting, the C&C to be connected  to is acquired dynamically via an HTTP request from a first layer server   The backdoor randomly chooses a domain from a list, which is present in the “IoCs” section  It resolves  the domain and sends an HTTP GET request to the acquired IP on a non-standard port for URL path  / iplist  The response is base64 decoded, decrypted by AES-128-CBC with key M4InzQpqqC18d1KL   and IV T4kP7mzlYR8DaLU3  The decrypted response is a host in format <ip>:<port> and connected to  later   The HTTP request is implemented using Poco::Net and crypto using Poco::Crypto  Version The constructor of its main class, which is called Backdoor throughout the code, contains a string that  appears to be a version number v6.0.3  This probably indicates that the project has been undergoing  active development  We have also found a sample with version number v6.0.2 and minor differences such as using a single  domain instead of a domain list to query the host  Initialization of communication The backdoor changes the default encryption key to a random one using  Poco::UUIDGenerator::reateRandom()  It is afterwards sent with system info nodeId:<ethernet_address>|nodeName:<uname>


OperationPair that changes system resources:
[<OP 9 act=write(), obj=/tmp.*>]

{
    "/proc/\\.inl": [
        "/proc/.inl"
    ],
    "/tmp.*": [
        "/tmp/.tmp_9SEtfj",
        "/tmp/.tmp_k4jzVl"
    ]
}