report,word,verb,objectType,prettyReg,match,label,asgSyscall,sentence
BPFDoor-CrowdStrike.csv,/var/run/lvm/vm,file_49,FILE,/var/run/.*,0,0,, Indicator	Platform	Purpose /run/lock/kdumpflush /run/lock/kdumpcab /var/lock/kdumpcab /var/lock/kdumpcache /dev/shm/kdmtmpflush /dev/shm/kdevtmpfls /dev/shm/ff	Linux	JustForFun implant pathnames (temporary – running process) /etc/avahi/avahi.conf /etc/cups/cups /etc/cups/cups.conf /etc/gofer/gofor.conf /etc/gss/gss.conf /etc/jvm/jvm.conf /etc/ntp/ntpd /etc/opt/opt.conf /etc/pm/pm.conf /etc/pulp/agent.conf /etc/ssl/ssl.conf /etc/sysconfig/kdumplog /etc/sysconfig/nfs.conf /etc/sysconfig/pcscd.conf /etc/xdg/xdg.conf /usr/java/jdk1.8.0_181-amd64/.java/init.d/jexecd /usr/local/mysql/bin/myisambug /lib64/libcaac.so.1	Linux	JustForFun implant pathnames (persistent – on disk) /lib/librbtinfo.so.1 /usr/lib/autofs/mountd /opt/VRTSvcs/bin/IP/online_Agent	Solaris	JustForFun implant pathnames /run/lock/lvv /run/lock/lvm/lv /var/run/lvm/vm /dev/shm/sem	Linux	JustForFun CLI utility pathnames /tmp/getuid.so /usr/lib/secure/getuid.so	Solaris	CVE-2019-3010 exploitation-related files (not unique to DecisiveArchitect) /usr/local/bin/GetADUsers.py /usr/local/bin/GetNPUsers.py /usr/local/bin/GetUserSPNs.py /usr/local/bin/atexec.py /usr/local/bin/dcomexec.py /usr/local/bin/dpapi.py /usr/local/bin/esentutl.py /usr/local/bin/getArch.py /usr/local/bin/getPac.py /usr/local/bin/getST.py /usr/local/bin/getTGT.py /usr/local/bin/goldenPac.py /usr/local/bin/ifmap.py /usr/local/bin/karmaSMB.py /usr/local/bin/lookupsid.py /usr/local/bin/mimikatz.py /usr/local/bin/mqtt_check.py /usr/local/bin/mssqlclient.py /usr/local/bin/mssqlinstance.py /usr/local/bin/netview.py /usr/local/bin/nmapAnswerMachine.py /usr/local/bin/ntfs-read.py /usr/local/bin/ntlmrelayx.py /usr/local/bin/opdump.py /usr/local/bin/ping.py /usr/local/bin/ping6.py /usr/local/bin/psexec.py /usr/local/bin/raiseChild.py /usr/local/bin/rdp_check.py /usr/local/bin/reg.py /usr/local/bin/registry-read.py /usr/local/bin/rpcdump.py /usr/local/bin/sambaPipe.py /usr/local/bin/samrdump.py /usr/local/bin/secretsdump.py /usr/local/bin/services.py /usr/local/bin/smbclient.py /usr/local/bin/smbexec.py /usr/local/bin/smbrelayx.py /usr/local/bin/smbserver.py /usr/local/bin/sniff.py /usr/local/bin/sniffer.py /usr/local/bin/split.py /usr/local/bin/ticketer.py /usr/local/bin/wmiexec.py /usr/local/bin/wmipersist.py /usr/local/bin/wmiquery.py	Linux	Impacket post-exploitation framework scripts (not unique to DecisiveArchitect) /usr/local/bin/ldapdomaindump /usr/local/bin/ldd2bloodhound	Linux	ldapdomaindump binaries used for Active Directory reconnaissance (not unique to DecisiveArchitect) c:\users\use.bat c:\users\one.ps1	Windows	Unknown scripts
BPFDoor-CrowdStrike.csv,https[:]//github.com/0xdea/exploits/blob/master/solaris/raptor_xscreensaver,endnote,MEM,"0x[0-9a-zA-Z]{1,16} (mem)",0,0,, Endnotes https[:]//github.com/0xdea/exploits/blob/master/solaris/raptor_xscreensaver Indicators of Compromise (IOCs)
BPFDoor-Qualys.csv,/var/run/xinetd.lock,file_7,FILE,/var/run/.*,0,0,, Filenames /dev/shm/kdmtmpflush /dev/shm/kdumpflush /dev/shm/kdumpdb /var/run/xinetd.lock /var/run/kdevrund.pid /var/run/haldrund.pid /var/run/syslogd.reboot
BPFDoor-Qualys.csv,/var/run/syslogd.reboot,,FILE,/var/run/.*,0,0,, Filenames /dev/shm/kdmtmpflush /dev/shm/kdumpflush /dev/shm/kdumpdb /var/run/xinetd.lock /var/run/kdevrund.pid /var/run/haldrund.pid /var/run/syslogd.reboot
BPFDoor-Qualys.csv,/var/run/haldrund.pid,create,FILE,/var/run/.*,1,1,open(), PID File The implant creates a zero-byte PID file at /var/run/haldrund.pid (Fig
BPFDoor-Qualys.csv,PID,create,ID,^PID.*,0,0,, PID File The implant creates a zero-byte PID file at /var/run/haldrund.pid (Fig
BPFDoor-Qualys.csv,PID,figure/get,ID,^PID.*,1,1,getppid() getpid(),Figure 11: Creation of PID file by BPFdoor
BPFDoor-deepinstinct.csv,“/var/run/initd.lock”,get,FILE,/var/run/.*,0,0,,"BPFdoor Technical Analysis When executed, the BPFdoor sample will attempt to create and get a lock on a runtime file at “/var/run/initd.lock” and will exit if it fails using that file as a makeshift mutex"
BPFDoor-deepinstinct.csv,/var/run/initd.lock,employ/create,FILE,/var/run/.*,1,1,open(),IOCs afa8a32ec29a31f152ba20a30eb483520fe50f2dce6c9aa9135d88f7c9c511d7 – BPFDoor ELF SHA256 /var/run/initd.lock – BPFDoor mutex” MITRE ATT&CK: Tactic	Technique	Description	Observable Command and Control Defense Evasion Persistence T1205 - Traffic Signaling Attacker employs “magic” values to trigger response
BPFDoor-exatrack.csv,/var/run/xinetd.lock,•,FILE,/var/run/.*,0,0,,• /var/run/xinetd.lock • /var/run/kdevrund.pid • /var/run/haldrund.pid • /var/run/syslogd.reboot  IOCs - Hashes • 07ecb1f2d9ffbd20a46cd36cd06b022db3cc8e45b1ecab62cd11f9ca7a26ab6d • a002f27f1abb599f24e727c811efa36d2d523e586a82134e9b3e8454dde6a089 • 8b84336e73c6a6d154e685d3729dfa4e08e4a3f136f0b2e7c6e5970df9145e95 • 76bf736b25d5c9aaf6a84edd4e615796fffc338a893b49c120c0b4941ce37925 • 96e906128095dead57fdc9ce8688bb889166b67c9a1b8fdb93d7cff7f3836bb9 • 599ae527f10ddb4625687748b7d3734ee51673b664f2e5d0346e64f85e185683 • 2e0aa3da45a0360d051359e1a038beff8551b957698f21756cfc6ed5539e4bdb • f47de978da1dbfc5e0f195745e3368d3ceef034e964817c66ba01396a1953d72 • 3347ddcc909c573a27c157f55d0444954e2b4b749bc65607a9f0319217954ac5 • 54a4b3c2ac34f1913634ab9be5f85cde19445d01260bb15bcd1d52ebcc85af2c (Variant with embedded configuration) • fa0defdabd9fd43fe2ef1ec33574ea1af1290bd3d763fdb2bed443f2bd996d73 (2018 variant) • 591198c234416c6ccbcea6967963ca2ca0f17050be7eed1602198308d9127c78 (unstripped variant) • dc8346bf443b7b453f062740d8ae8d8d7ce879672810f4296158f90359dcae3a (Solaris Variant)  IOCs - Yara rule rule Linux_TricephalicImplant {  meta:  author = Exatrack  description = Detect Linux passive backdoors  tlp = WHITE  source = Exatrack  strings:  $str_message_01 = hald-addon-acpi: listening on acpi kernel interface /proc/acpi/event  $str_message__02 = /var/run/haldrund.pid  $str_message_03 = /bin/rm -f /dev/shm/%s;/bin/cp %s /dev/shm/%s && /bin/chmod 755 /dev/shm/%s && /dev/shm/%s --init && /bin/rm -f /dev/shm/%s // in the stack  $str_message_04 = Cant fork pty  $str_hald_05 = /sbin/iptables -t nat -D PREROUTING -p tcp -s %s --dport %d -j REDIRECT --to-ports %d  $str_command_01 = /sbin/iptables -t nat -A PREROUTING -p tcp -s %s --dport %d -j REDIRECT --to-ports %d  $str_command_02 = /sbin/iptables -I INPUT -p tcp -s %s -j ACCEPT  $str_command_03 = /bin/rm -f /dev/shm/%s  $str_command_04 = /bin/cp %s /dev/shm/%s  $str_command_05 = /bin/chmod 755 /dev/shm/%s  $str_command_06 = /dev/shm/%s --init  $str_server_01 = [+] Spawn shell ok.  $str_server_02 = [+] Monitor packet send
BPFDoor-exatrack.csv,0x7255,check,MEM,"0x[0-9a-zA-Z]{1,16} (mem)",0,0,,"$error_07 = [-] setsockopt  $error_08 = [-] missing -s  $error_09 = [-] sendto  condition:  any of ($str*) or 3 of ($error*) }  Disassembled BPF bytecode  // Filter for IPv4 traffic  0 28 00 00 00 0c 00 00 00 ldh [0xc]  8 15 00 00 1b 00 08 00 00 jeq 0x800, +0x0, +0x1b  10 30 00 00 00 17 00 00 00 ldb [0x17]  // Check for UDP  18 15 00 00 05 11 00 00 00 jeq 0x11, +0x0, +0x5  20 28 00 00 00 14 00 00 00 ldh [0x14]  28 45 00 17 00 ff 1f 00 00 jset 0x1fff, +0x17, +0x0  // Get packet first 2 bytes of data  30 b1 00 00 00 0e 00 00 00 ldxb 4*([0xe]&0xf)  38 48 00 00 00 16 00 00 00 ldh [x+0x16]  // Check for trigger marker 0x7255  40 15 00 13 14 55 72 00 00 jeq 0x7255, +0x13, +0x14  // Check for TCP protocol  48 15 00 00 07 01 00 00 00 jeq 0x1, +0x0, +0x7  // Get packet first two bytes  50 28 00 00 00 14 00 00 00 ldh [0x14]  58 45 00 11 00 ff 1f 00 00 jset 0x1fff, +0x11, +0x0  60 b1 00 00 00 0e 00 00 00 ldxb 4*([0xe]&0xf  68 48 00 00 00 16 00 00 00 ldh [x+0x16]  // Check for trigger marker  70 15 00 00 0e 55 72 00 00 jeq 0x7255, +0x0, +0xe  // Check for TCP packet format  78 50 00 00 00 0e 00 00 00 ldb [x+0xe]  80 15 00 0b 0c 08 00 00 00 jeq 0x8, +0xb, +0xc  88 15 00 00 0b 06 00 00 00 jeq 0x6, +0x0, +0xb  90 28 00 00 00 14 00 00 00 ldh [0x14]  98 45 00 09 00 ff 1f 00 00 jset 0x1fff, +0x9, +0x0  // Get packet data  a0 b1 00 00 00 0e 00 00 00 ldxb 4*([0xe]&0xf)  a8 50 00 00 00 1a 00 00 00 ldb [x+0x1a]  b0 54 00 00 00 f0 00 00 00 and 0xf0  b8 74 00 00 00 02 00 00 00 rsh 0x2  c0 0c 00 00 00 00 00 00 00 add x  c8 07 00 00 00 00 00 00 00 tax  d0 48 00 00 00 0e 00 00 00 ldh [x+0xe]  // Filter for trigger packet (this time 0x5293)  d8 15 00 00 01 93 52 00 00 jeq 0x5293, +0x0, +0x1  e0 06 00 00 00 ff ff 00 00 ret 0xffff  e8 06 00 00 00 00 00 00 00 ret 0x0  List of process names This is a partial list of process names which can be used by the malware to masquerade himself"
BPFDoor-exatrack.csv,0x1e;,,MEM,"0x[0-9a-zA-Z]{1,16} (mem)",0,0,,"The pseudo-code of the filter installation and packet parsing loop look like this: sock_fprog fprog;  [...]  // Simplified copy loop  memcpy(&stored_data, &filter_bytecode, 0x1e * 8);  [...]  fprog.len = 0x1e;  fprog.filter = &stored_data;   // Create a raw socket  hSocket = socket(AF_PACKET,SOCK_RAW,(uint)uVar1);  if ((hSocket < 1) || (iVar2 = setsockopt(hSocket, 1, SO_ATTACH_FILTER, &fprog, sizeof(sock_fprog)), iVar2 == -1)) {  return;  }  while( true ) {  do {  do {  memset(received_buffer,0,0x200);  recvfrom(dwCMD,received_buffer,0x200,0,(sockaddr *)0x0,(socklen_t *)0x0);   // Now, parse the packet  [...]  We chose to dump it from the sample, and developed a BPF processor for Ghidra [7] to disassemble it"
BPFDoor-exatrack.csv,0x7255,start,MEM,"0x[0-9a-zA-Z]{1,16} (mem)",0,0,,"This time the filter could be found in text form, which confirmed our analysis of the BPF byte code: (udp[8:2]=0x7255) or (icmp[8:2]=0x7255) or (tcp[((tcp[12]&0xf0)>>2):2]=0x5293) We can deduce from this that the backdoor can be triggered by three different means: 1) An UDP packet starting with the bytes 0x7255 2) An ICMP packet also starting with the bytes 0x7255 A TCP packet starting with the bytes 0x5293"
BPFDoor-exatrack.csv,0x7255,look,MEM,"0x[0-9a-zA-Z]{1,16} (mem)",0,0,,"This processor will be released shortly after some more testing :) The disassembled graph is the following: BPF Bytecode disassembly  The BPF bytecode processes the packet in several steps: 1) Filter for IPv4 traffic 2) Triage between UDP / TCP or ICMP traffic 3) Get the first 2 bytes of packet data 4) Check if these 2 bytes looks like a trigger packet (0x5293 for TCP, 0x7255 for UDP and ICMP) 5) Return the packet if true  While searching for similar samples, we also found a Solaris variant of this malware"
BPFDoor-exatrack.csv,0x1e,create/set,MEM,"0x[0-9a-zA-Z]{1,16} (mem)",1,1,arch_prctl() mprotect() set_tid_address() set_robust_list(),"The pseudo-code of the filter installation and packet parsing loop look like this: sock_fprog fprog;  [...]  // Simplified copy loop  memcpy(&stored_data, &filter_bytecode, 0x1e * 8);  [...]  fprog.len = 0x1e;  fprog.filter = &stored_data;   // Create a raw socket  hSocket = socket(AF_PACKET,SOCK_RAW,(uint)uVar1);  if ((hSocket < 1) || (iVar2 = setsockopt(hSocket, 1, SO_ATTACH_FILTER, &fprog, sizeof(sock_fprog)), iVar2 == -1)) {  return;  }  while( true ) {  do {  do {  memset(received_buffer,0,0x200);  recvfrom(dwCMD,received_buffer,0x200,0,(sockaddr *)0x0,(socklen_t *)0x0);   // Now, parse the packet  [...]  We chose to dump it from the sample, and developed a BPF processor for Ghidra [7] to disassemble it"
BPFDoor-exatrack.csv,0x490a083c,set,MEM,"0x[0-9a-zA-Z]{1,16} (mem)",0,0,,The timestamp used was always set to 0x490a083c (2008-10-30T20:17:16)
BPFDoor-github.csv,0x00040000,ret,MEM,"0x[0-9a-zA-Z]{1,16} (mem)",0,0,,"$ sudo tcpdump -i wlp4s0 -d tcp port 80 (000) ldh      [12]                             # { 0x28, 0, 0, 0x0000000c } (001) jeq      #0x86dd          jt 2   jf 8     # { 0x15, 0, 6, 0x000086dd } (002) ldb      [20]                             # { 0x30, 0, 0, 0x00000014 } (003) jeq      #0x6             jt 4   jf 19    # { 0x15, 0, 15, 0x00000006 } (004) ldh      [54]                             # { 0x28, 0, 0, 0x00000036 } (005) jeq      #0x50            jt 18  jf 6     # { 0x15, 12, 0, 0x00000050 } (006) ldh      [56]                             # { 0x28, 0, 0, 0x00000038 } (007) jeq      #0x50            jt 18  jf 19    # { 0x15, 10, 11, 0x00000050 } (008) jeq      #0x800           jt 9   jf 19    # { 0x15, 0, 10, 0x00000800 } (009) ldb      [23]                             # { 0x30, 0, 0, 0x00000017 } (010) jeq      #0x6             jt 11  jf 19    # { 0x15, 0, 8, 0x00000006 } (011) ldh      [20]                             # { 0x28, 0, 0, 0x00000014 } (012) jset     #0x1fff          jt 19  jf 13    # { 0x45, 6, 0, 0x00001fff } (013) ldxb     4*([14]&0xf)                     # { 0xb1, 0, 0, 0x0000000e } (014) ldh      [x + 14]                         # { 0x48, 0, 0, 0x0000000e } (015) jeq      #0x50            jt 18  jf 16    # { 0x15, 2, 0, 0x00000050 } (016) ldh      [x + 16]                         # { 0x48, 0, 0, 0x00000010 } (017) jeq      #0x50            jt 18  jf 19    # { 0x15, 0, 1, 0x00000050 } (018) ret      #262144                          # { 0x6, 0, 0, 0x00040000 } (019) ret      #0                               # { 0x6, 0, 0, 0x00000000 } Studying the BPF Bytecode in BPFDoor Building Capstone Given BPF bytecode, we can use capstone to disassemble it"
BPFDoor-github.csv,"0x28,",,MEM,"0x[0-9a-zA-Z]{1,16} (mem)",0,0,,"$ sudo tcpdump -i wlp4s0 -d tcp port 80 (000) ldh      [12]                             # { 0x28, 0, 0, 0x0000000c } (001) jeq      #0x86dd          jt 2   jf 8     # { 0x15, 0, 6, 0x000086dd } (002) ldb      [20]                             # { 0x30, 0, 0, 0x00000014 } (003) jeq      #0x6             jt 4   jf 19    # { 0x15, 0, 15, 0x00000006 } (004) ldh      [54]                             # { 0x28, 0, 0, 0x00000036 } (005) jeq      #0x50            jt 18  jf 6     # { 0x15, 12, 0, 0x00000050 } (006) ldh      [56]                             # { 0x28, 0, 0, 0x00000038 } (007) jeq      #0x50            jt 18  jf 19    # { 0x15, 10, 11, 0x00000050 } (008) jeq      #0x800           jt 9   jf 19    # { 0x15, 0, 10, 0x00000800 } (009) ldb      [23]                             # { 0x30, 0, 0, 0x00000017 } (010) jeq      #0x6             jt 11  jf 19    # { 0x15, 0, 8, 0x00000006 } (011) ldh      [20]                             # { 0x28, 0, 0, 0x00000014 } (012) jset     #0x1fff          jt 19  jf 13    # { 0x45, 6, 0, 0x00001fff } (013) ldxb     4*([14]&0xf)                     # { 0xb1, 0, 0, 0x0000000e } (014) ldh      [x + 14]                         # { 0x48, 0, 0, 0x0000000e } (015) jeq      #0x50            jt 18  jf 16    # { 0x15, 2, 0, 0x00000050 } (016) ldh      [x + 16]                         # { 0x48, 0, 0, 0x00000010 } (017) jeq      #0x50            jt 18  jf 19    # { 0x15, 0, 1, 0x00000050 } (018) ret      #262144                          # { 0x6, 0, 0, 0x00040000 } (019) ret      #0                               # { 0x6, 0, 0, 0x00000000 } Studying the BPF Bytecode in BPFDoor Building Capstone Given BPF bytecode, we can use capstone to disassemble it"
BPFDoor-github.csv,+0x0,perform,MEM,"0x[0-9a-zA-Z]{1,16} (mem)",0,0,,"This instruction checks if the destination port number is 443  11: jeq 0x800, +0x0, +0x11 Line 11 Instruction  12: ldb [0x17] Line 12 Instruction  13: jeq 0x6, +0x0, +0x6 Line 13 Instruction  14: ldh [0x14] Line 14 Instruction  15: jset 0x1fff, +0xd, +0x0 This instruction performs a bitwise AND operation between the previously loaded value at line 14 and 0x1fff"
BPFDoor-github.csv,+0xd,jump/ummap,MEM,"0x[0-9a-zA-Z]{1,16} (mem)",1,1,munmap(),"0: ldh [0xc] Line 0 Instruction  1: jeq 0x86dd, +0x0, +0x9 Line 1 Instruction  2: ldb [0x14] Line 2 Instruction  3: jeq 0x6 , +0x0, +0x2 Line 3 Instruction  4: ldh [0x38] Line 4 Instruction  5: jeq 0x50, +0x16, +0xd If the previously loaded value at line 4 matches 0x50, control jumps to line 28 (relative offset 0x16) else it jumps to line 19 (relative offset 0xd)"
BPFDoor-github.csv,0x00000014,0x50,MEM,"0x[0-9a-zA-Z]{1,16} (mem)",0,0,,"$ sudo tcpdump -i wlp4s0 -d tcp port 80 (000) ldh      [12]                             # { 0x28, 0, 0, 0x0000000c } (001) jeq      #0x86dd          jt 2   jf 8     # { 0x15, 0, 6, 0x000086dd } (002) ldb      [20]                             # { 0x30, 0, 0, 0x00000014 } (003) jeq      #0x6             jt 4   jf 19    # { 0x15, 0, 15, 0x00000006 } (004) ldh      [54]                             # { 0x28, 0, 0, 0x00000036 } (005) jeq      #0x50            jt 18  jf 6     # { 0x15, 12, 0, 0x00000050 } (006) ldh      [56]                             # { 0x28, 0, 0, 0x00000038 } (007) jeq      #0x50            jt 18  jf 19    # { 0x15, 10, 11, 0x00000050 } (008) jeq      #0x800           jt 9   jf 19    # { 0x15, 0, 10, 0x00000800 } (009) ldb      [23]                             # { 0x30, 0, 0, 0x00000017 } (010) jeq      #0x6             jt 11  jf 19    # { 0x15, 0, 8, 0x00000006 } (011) ldh      [20]                             # { 0x28, 0, 0, 0x00000014 } (012) jset     #0x1fff          jt 19  jf 13    # { 0x45, 6, 0, 0x00001fff } (013) ldxb     4*([14]&0xf)                     # { 0xb1, 0, 0, 0x0000000e } (014) ldh      [x + 14]                         # { 0x48, 0, 0, 0x0000000e } (015) jeq      #0x50            jt 18  jf 16    # { 0x15, 2, 0, 0x00000050 } (016) ldh      [x + 16]                         # { 0x48, 0, 0, 0x00000010 } (017) jeq      #0x50            jt 18  jf 19    # { 0x15, 0, 1, 0x00000050 } (018) ret      #262144                          # { 0x6, 0, 0, 0x00040000 } (019) ret      #0                               # { 0x6, 0, 0, 0x00000000 } Studying the BPF Bytecode in BPFDoor Building Capstone Given BPF bytecode, we can use capstone to disassemble it"
BPFDoor-github.csv,+0x9,jset,MEM,"0x[0-9a-zA-Z]{1,16} (mem)",0,0,,"0: ldh [0xc] 1: jeq 0x86dd, +0x0, +0x9 2: ldb [0x14] 3: jeq 0x6 , +0x0, +0x2 4: ldh [0x38] 5: jeq 0x50, +0x16, +0xd 6: jeq 0x2c, +0x16, +0x0 7: jeq 0x84, +0x1, +0x0 8: jeq 0x11, +0x0, +0x14 9: ldh [0x38] 10: jeq 0x1bb, +0x11, +0x10 11: jeq 0x800, +0x0, +0x11 12: ldb [0x17] 13: jeq 0x6, +0x0, +0x6 14: ldh [0x14] 15: jset 0x1fff, +0xd, +0x0 16: ldxb 4*([14]&0xf) 17: ldh [x+0x10] 18: jeq 0x50, +0x9, +0x0 19: jeq 0x1bb, +0x8, +0x7 20: jeq 0x84, +0x1, +0x0 21: jeq 0x11, +0x0, +0x7 22: ldh [0x14] 23: jset 0x1fff, +0x5, +0x0 24: ldxb 4*([14]&0xf) 25: ldh [x+0x10] 26: jeq 0x1bb, +0x1, +0x0 27: jeq 0x16, +0x0, +0x1 28: ret 0x40000 29: ret 0x0 Interpreting BPFDoor’s BPF Bytecode BPFDoor attaches the cBPF program to a AF_PACKET socket"
BPFDoor-github.csv,+0xd,fail/set,MEM,"0x[0-9a-zA-Z]{1,16} (mem)",1,1,arch_prctl() mprotect() set_tid_address() set_robust_list(),"In [1]: from capstone import *  In [2]: md = Cs(CS_ARCH_BPF, CS_MODE_BPF_CLASSIC)  In [3]: with open(bpf.o, rb) as ff:    ...:     data = ff.read()    ...: linenum = 0    ...: for i in md.disasm(data, 0):    ...:     print(f{j}: {i.mnemonic} {i.op_str})    ...:     linenum += 1  0: ldh [0xc] 1: jeq 0x86dd, +0x0, +0x9 2: ldb [0x14] 3: jeq 0x6, +0x0, +0x2 4: ldh [0x38] 5: jeq 0x50, +0x16, +0xd 6: jeq 0x2c, +0x16, +0x0 7: jeq 0x84, +0x1, +0x0 8: jeq 0x11, +0x0, +0x14 9: ldh [0x38] 10: jeq 0x1bb, +0x11, +0x10 11: jeq 0x800, +0x0, +0x11 12: ldb [0x17] 13: jeq 0x6, +0x0, +0x6 14: ldh [0x14] 15: jset 0x1fff, +0xd, +0x0 capstone failed to disassemble the 17th instruction"
BPFDoor-github.csv,+0x11,be,MEM,"0x[0-9a-zA-Z]{1,16} (mem)",0,0,,"This instruction checks if the destination port number is 443  11: jeq 0x800, +0x0, +0x11 Line 11 Instruction  12: ldb [0x17] Line 12 Instruction  13: jeq 0x6, +0x0, +0x6 Line 13 Instruction  14: ldh [0x14] Line 14 Instruction  15: jset 0x1fff, +0xd, +0x0 This instruction performs a bitwise AND operation between the previously loaded value at line 14 and 0x1fff"
BPFDoor-sandflysecurity.csv,/var/run/haldrund.pid,,FILE,/var/run/.*,0,0,, Dropper if implant active or did not clean up: /var/run/haldrund.pid 
BPFDoor-sandflysecurity.csv,/var/run/haldrund.pid,create,FILE,/var/run/.*,1,1,open(),5) The forked version creates a dropper at /var/run/haldrund.pid to mark it is resident and prevent multiple starts
BPFDoor-sandflysecurity.csv,permissions,need,FILE,Permission/Permission:[0-9]{3},0,0,,"However, the binary does need root permissions to run"
BPFDoor-sandflysecurity.csv,PID,masquerade,ID,^PID.*,0,0,,The controlling PID will be masquerading running under the name: /usr/libexec/postfix/master
BPFDoor-sandflysecurity.csv,PID,create,ID,^PID.*,0,0,,PID Dropper The implant creates a zero byte PID file at /var/run/haldrund.pid
BPFDoor-sandflysecurity.csv,PID,be,ID,^PID.*,0,0,,The red arrow is the PID in question running BPFDoor
BPFDoor-sandflysecurity.csv,A==0x7255,file_14,MEM,"0x[0-9a-zA-Z]{1,16} (mem)",0,0,,"The commented assembly and pseudocode is here: l0:     ldh [12]                // A = halfword from offset 12 [Ethernet: EtherType] l1:     jeq #0x800, l2, l29     // if EtherType==IPv4 goto l2; else goto l29 l2:     ldb [23]                // A = byte from packet offset 23 [IPv4: Protocol]  (data begins at offset 14 of ethernet packet; so this is offset 9 in the IPv4 packet) l3:     jeq #0x11, l4, l9       // if Protocol==UDP goto l4, else goto l9 l4:     ldh [20]                // A = IPv4 flags+fragment offset l5:     jset #0x1fff, l29, l6   // ...if fragmentation offset != 0, goto l29 l6:     ldxb 4*([14]&0xf)       // X = IPv4 Header Length l7:     ldh [x+22]              // A = halfword from offset X+22... first halfword of UDP datagram data l8:     jeq #0x7255, l28, l29   // if A==0x7255 goto l28, else goto l29 l9:     jeq #0x1, l10, l17      // if Protocol==ICMP goto l10, else goto l17 (jumped to from l3; register contains IP protocol) l10:    ldh [20]                // A = IPv4 flags+fragment offset l11:    jset #0x1fff, l29, l12  // ...if fragmentation offset != 0, goto l29 l12:    ldxb 4*([14]&0xf)       // X = IPv4 Header Length l13:    ldh [x+22]              // A = halfword from offset X+22... first halfword of ICMP data l14:    jeq #0x7255, l15, l29   // if A==0x7255 goto l15, else goto l29 l15:    ldb [x+14]              // A = byte from offset X+14... ICMP Type l16:    jeq #0x8, l28, l29      // if ICMP Type == Echo Request (ping) goto l28, else goto l29 l17:    jeq #0x6, l18, l29      // if Protocol==TCP goto l18, else goto l29 (jumped to from l3; register contains IP protocol) l18:    ldh [20]                // A = IPv4 flags+fragment offset l19:    jset #0x1fff, l29, l20  // ...if fragmentation offset != 0, goto l29 l20:    ldxb 4*([14]&0xf)       // X = IPv4 Header Length l21:    ldb [x+26]              // A = byte from offset X+26"
BPFDoor-sandflysecurity.csv,"#0x800,",,MEM,"0x[0-9a-zA-Z]{1,16} (mem)",0,0,,"The commented assembly and pseudocode is here: l0:     ldh [12]                // A = halfword from offset 12 [Ethernet: EtherType] l1:     jeq #0x800, l2, l29     // if EtherType==IPv4 goto l2; else goto l29 l2:     ldb [23]                // A = byte from packet offset 23 [IPv4: Protocol]  (data begins at offset 14 of ethernet packet; so this is offset 9 in the IPv4 packet) l3:     jeq #0x11, l4, l9       // if Protocol==UDP goto l4, else goto l9 l4:     ldh [20]                // A = IPv4 flags+fragment offset l5:     jset #0x1fff, l29, l6   // ...if fragmentation offset != 0, goto l29 l6:     ldxb 4*([14]&0xf)       // X = IPv4 Header Length l7:     ldh [x+22]              // A = halfword from offset X+22... first halfword of UDP datagram data l8:     jeq #0x7255, l28, l29   // if A==0x7255 goto l28, else goto l29 l9:     jeq #0x1, l10, l17      // if Protocol==ICMP goto l10, else goto l17 (jumped to from l3; register contains IP protocol) l10:    ldh [20]                // A = IPv4 flags+fragment offset l11:    jset #0x1fff, l29, l12  // ...if fragmentation offset != 0, goto l29 l12:    ldxb 4*([14]&0xf)       // X = IPv4 Header Length l13:    ldh [x+22]              // A = halfword from offset X+22... first halfword of ICMP data l14:    jeq #0x7255, l15, l29   // if A==0x7255 goto l15, else goto l29 l15:    ldb [x+14]              // A = byte from offset X+14... ICMP Type l16:    jeq #0x8, l28, l29      // if ICMP Type == Echo Request (ping) goto l28, else goto l29 l17:    jeq #0x6, l18, l29      // if Protocol==TCP goto l18, else goto l29 (jumped to from l3; register contains IP protocol) l18:    ldh [20]                // A = IPv4 flags+fragment offset l19:    jset #0x1fff, l29, l20  // ...if fragmentation offset != 0, goto l29 l20:    ldxb 4*([14]&0xf)       // X = IPv4 Header Length l21:    ldb [x+26]              // A = byte from offset X+26"
BPFDoor-sandflysecurity.csv,A==0x5293,return,MEM,"0x[0-9a-zA-Z]{1,16} (mem)",0,0,,"l25:    tax                     // X = A l26:    ldh [x+14]              // A = halfword from packet offset X+14 (14 is ethernet header, x is IPv4+TCP header, so this offset is first TCP payload byte) l27:    jeq #0x5293, l28, l29   // if A==0x5293 goto l28, else goto l29 l28:    ret #0xffff             // return match l29:    ret #0                  // return doesn't-match Pseudocode"
BPFDoor-sandflysecurity.csv,0xF0,offset,MEM,"0x[0-9a-zA-Z]{1,16} (mem)",0,0,,"Assume no IPv4 options so X=20; packet offset 46 = TCP segment offset 12 l22:    and #0xf0               // A = A & 0xF0 (high nibble of TCP offset 12 = Data offset = TCP header size in 32-bit words) l23:    rsh #2                  // A = A >> 2 (this has the effect of multiplying the high nibble by four, e.g A>>4 then A<<2)"
BPFDoor-unfinished.bike.csv,"/var/run/initd.lock,",remove,FILE,/var/run/.*,0,0,,"Running bpfdoor as a regular user  I first ran bpfdoor as an unprivileged user to see what system calls would be executed:  strace -o /tmp/st.user -f ./x.bin   I've removed the less interesting lines of output, but the program does astonishingly little:  2655  execve(./x.bin, [./x.bin], 0x7fff9dad6ff8 /* 23 vars */) = 0 2655  openat(AT_FDCWD, /lib/x86_64-linux-gnu/libc.so.6, O_RDONLY|O_CLOEXEC) = 3 2655  openat(AT_FDCWD, /var/run/initd.lock, O_RDWR|O_CREAT, 0666) = -1 EACCES (Permission denied) 2655  flock(-1, LOCK_EX|LOCK_NB)        = -1 EBADF (Bad file descriptor) 2655  clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7ff8d1b39a10) = 2656 2655  +++ exited with 0 +++ 2656  close(0)                          = 0 2656  close(1)                          = 0 2656  close(2)                          = 0 2656  setsid()                          = 2656 2656  getrandom(\xa4\xd5\x9d\x71\xb3\xe0\x98\xe1, 8, GRND_NONBLOCK) = 8 2656  socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL)) = -1 EPERM (Operation not permitted) 2656  exit_group(0)                     = ?"
BPFDoor-unfinished.bike.csv,"/var/run/initd.lock,",run,FILE,/var/run/.*,0,0,,"Running as root  2669  openat(AT_FDCWD, /var/run/initd.lock, O_RDWR|O_CREAT, 0666) = 3 2669  flock(3, LOCK_EX|LOCK_NB)         = 0 2669  clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb6d948ba10) = 3319 2669  exit_group(0 <unfinished ...> 3319  close(0 <unfinished ...> 2669  +++ exited with 0 +++ 3319  close(1)                          = 0 3319  close(2)                          = 0 3319  setsid()                          = 3319 3319  getrandom(\x6c\x07\x1c\x75\x6b\xae\xfe\xdf, 8, GRND_NONBLOCK) = 8 3319  socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL)) = 0 3319  setsockopt(0, SOL_SOCKET, SO_ATTACH_FILTER, {len=30, filter=0x7ffd2270fa90}, 16) = 0 3319  recvfrom(0, RUU\341\314\22RU\300\250\5\2\10\0E\0\0Lp\220\0\0@\6~\272\300\250\5\2\300\250..., 65536, 0, NULL, NULL) = 90 3319  recvfrom(0, RUU\341\314\22RU\300\250\5\2\10\0E\0\0(p\221\0\0@\6~\335\300\250\5\2\300\250..., 65536, 0, NULL, NULL) = 54 3319  recvfrom(0, RUU\341\314\22RU\300\250\5\2\10\0E\0\0Lp\222\0\0@\6~\270\300\250\5\2\300\250..., 65536, 0, NULL, NULL) = 90 3319  recvfrom(0, RUU\341\314\22RU\300\250\5\2\10\0E\0\0(p\223\0\0@\6~\333\300\250\5\2\300\250..., 65536, 0, NULL, NULL) = 54   First, it opens a lock, which works this time:  -rw-r--r-- 1 root root 0 May 13 12:45 /run/initd.lock   As mentioned in the bpfdoor analysis by deep instinct, we can see that it sets a BPF filter via setsockopt(), and loops waiting for the magic byte sequence: \x44\x30\xCD\x9F\x5E\x14\x27\x66"
BPFDoor-unfinished.bike.csv,/var/run/initd.lock,bundle,FILE,/var/run/.*,0,0,,"% sudo lsof -p 3319  COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME x.bin   3319 root  cwd    DIR   0,52      200    9 /tmp/lima/osquery-defense-kit/out x.bin   3319 root  rtd    DIR  252,1     4096    2 / x.bin   3319 root  txt    REG  252,1   302576 3210 /tmp/x.bin x.bin   3319 root  mem    REG  252,1  2072888 3648 /usr/lib/x86_64-linux-gnu/libc.so.6 x.bin   3319 root  mem    REG  252,1   228720 3645 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 x.bin   3319 root    0u  pack  33049      0t0  ALL type=SOCK_RAW x.bin   3319 root    3u   REG   0,25        0 1322 /run/initd.lock   lsof is handy, but to see the raw socket from /proc, we need to do a little bit more digging:  # cat /proc/net/packet  sk               RefCnt Type Proto  Iface R Rmem   User   Inode ffff92d346ba6800 3      3    88cc   2     1 0      100    19458  ffff92d34631d800 3      3    0003   0     1 241920 0      33089    The Inode field is misleading, but you can use it to find the associated process ID via:  $ sudo find /proc -type l -lname socket:\[33089\] 2>/dev/null  /proc/3319/task/3319/fd/0 /proc/3319/fd/0   Alternatively, you can use this to see all filehandles for the process ID:  $ ls -la /proc/3319/fd  total 0 dr-x------ 2 root root  0 May 13 13:03 . dr-xr-xr-x 9 root root  0 May 13 13:03 .. lrwx------ 1 root root 64 May 13 13:03 0 -> 'socket:[33089]' lrwx------ 1 root root 64 May 13 13:03 3 -> /run/initd.lock   Once you have a process ID, you can resolve the path to the program:  sudo ls -lad /proc/3319/exe  lrwxrwxrwx 1 root root 0 May 14 00:48 /proc/3319/exe -> /tmp/x.bin   Exploring bpfdoor using strings  Running strings <path> reveals some interesting messages:  [-] Execute command failed /var/run/initd.lock   libtom/libtomcrypt has been bundled in, so we see lines such as:  LTC_ARGCHK '%s' failure on line %d of file %s X.509v%i certificate   Issued by: [%s]%s (%s)   Issued to: [%s]%s (%s, %s)   Subject: %s   Validity: %s - %s   OCSP: %s   Serial number: ... LibTomCrypt 1.17 (Tom St Denis, tomstdenis@gmail.com) LibTomCrypt is public domain software"
BPFDoor-unfinished.bike.csv,/var/run/initd.lock,create,FILE,/var/run/.*,1,1,open(),2656  +++ exited with 0 +++   The only noteworthy things here are: It tries to create /var/run/initd.lock but fails because it requires root  It tries to set up a raw socket to listen to all protocols but fails because it requires root
BPFDoor-unfinished.bike.csv,permissions,use,FILE,Permission/Permission:[0-9]{3},0,0,,Malware often uses very relaxed file permissions
BPFDoor-unfinished.bike.csv,(Permission,,FILE,Permission/Permission:[0-9]{3},0,0,,"Running bpfdoor as a regular user  I first ran bpfdoor as an unprivileged user to see what system calls would be executed:  strace -o /tmp/st.user -f ./x.bin   I've removed the less interesting lines of output, but the program does astonishingly little:  2655  execve(./x.bin, [./x.bin], 0x7fff9dad6ff8 /* 23 vars */) = 0 2655  openat(AT_FDCWD, /lib/x86_64-linux-gnu/libc.so.6, O_RDONLY|O_CLOEXEC) = 3 2655  openat(AT_FDCWD, /var/run/initd.lock, O_RDWR|O_CREAT, 0666) = -1 EACCES (Permission denied) 2655  flock(-1, LOCK_EX|LOCK_NB)        = -1 EBADF (Bad file descriptor) 2655  clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7ff8d1b39a10) = 2656 2655  +++ exited with 0 +++ 2656  close(0)                          = 0 2656  close(1)                          = 0 2656  close(2)                          = 0 2656  setsid()                          = 2656 2656  getrandom(\xa4\xd5\x9d\x71\xb3\xe0\x98\xe1, 8, GRND_NONBLOCK) = 8 2656  socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL)) = -1 EPERM (Operation not permitted) 2656  exit_group(0)                     = ?"
BPFDoor-unfinished.bike.csv,pid,do,ID,^PID.*,0,0,,"SELECT * FROM file WHERE path LIKE /tmp/%.lock AND mode = 0644;   find /run/*.lock -perm 644   Minimalist socket users with few open files  This creative query reveals minimalist programs that behave like a backdoor might: have 0-1 open files  have 1-2 sockets open   It's an uncommon situation, but it is bound to have false positives in software that is designed in a way that each process has a specific role:  SELECT p.pid,     p.path,     p.name,     p.start_time,     GROUP_CONCAT(DISTINCT pos.protocol) AS protocols,     pof.path AS pof_path,     COUNT(DISTINCT pos.fd) AS scount,     COUNT(DISTINCT pof.path) AS fcount,     GROUP_CONCAT(DISTINCT pof.path) AS open_files,     p.cgroup_path FROM processes p     JOIN process_open_sockets pos ON p.pid = pos.pid     AND pos.protocol > 0     LEFT JOIN process_open_files pof ON p.pid = pof.pid WHERE p.start_time < (strftime('%s', 'now') -60) AND p.path NOT IN (     '/bin/registry',     '/usr/bin/docker-proxy',     '/usr/sbin/chronyd',     '/usr/sbin/cups-browsed',     '/usr/sbin/cupsd',     '/usr/sbin/sshd' ) AND p.path NOT LIKE '/nix/store/%-openssh-%/bin/sshd' GROUP BY p.pid HAVING scount <= 2     AND fcount <= 1;   cd /proc || exit  for pid in *; do     [[ !"
BPFDoor-unfinished.bike.csv,"pid=${pid},",,ID,^PID.*,0,0,,"Use grep -o instead of -c     #ss -xp | grep -v ^u_ | grep -o pid=${pid},      all_sockets=$(find /proc/${pid}/fd -lname socket:* | wc -l)     [[ ${all_sockets} -gt 2 ]] && continue      # this isn't exactly what we want - ss doesn't show TYPE=sock of protocol=UNIX :(     unix_sockets=$(ss -ap | grep ^u_ | grep -o pid=${pid}, | wc -l)     sockets=$(($all_sockets - $unix_sockets))      [[ ${sockets} == 0 ]] && continue     [[ ${sockets} -gt 2 ]] && continue      path=$(readlink /proc/$pid/exe)     [[ ${path} == /usr/sbin/sshd ]] && continue      name=$(cat /proc/$pid/comm)     echo minimalist socket user (${sockets} sockets and ${fds} files): ${name} [${pid}] at ${path} done    fd0 is a socket  I've saved my favorite for last"
BPFDoor-unfinished.bike.csv,PID,file_1,ID,^PID.*,0,0,,"% sudo lsof -p 3319  COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME x.bin   3319 root  cwd    DIR   0,52      200    9 /tmp/lima/osquery-defense-kit/out x.bin   3319 root  rtd    DIR  252,1     4096    2 / x.bin   3319 root  txt    REG  252,1   302576 3210 /tmp/x.bin x.bin   3319 root  mem    REG  252,1  2072888 3648 /usr/lib/x86_64-linux-gnu/libc.so.6 x.bin   3319 root  mem    REG  252,1   228720 3645 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 x.bin   3319 root    0u  pack  33049      0t0  ALL type=SOCK_RAW x.bin   3319 root    3u   REG   0,25        0 1322 /run/initd.lock   lsof is handy, but to see the raw socket from /proc, we need to do a little bit more digging:  # cat /proc/net/packet  sk               RefCnt Type Proto  Iface R Rmem   User   Inode ffff92d346ba6800 3      3    88cc   2     1 0      100    19458  ffff92d34631d800 3      3    0003   0     1 241920 0      33089    The Inode field is misleading, but you can use it to find the associated process ID via:  $ sudo find /proc -type l -lname socket:\[33089\] 2>/dev/null  /proc/3319/task/3319/fd/0 /proc/3319/fd/0   Alternatively, you can use this to see all filehandles for the process ID:  $ ls -la /proc/3319/fd  total 0 dr-x------ 2 root root  0 May 13 13:03 . dr-xr-xr-x 9 root root  0 May 13 13:03 .. lrwx------ 1 root root 64 May 13 13:03 0 -> 'socket:[33089]' lrwx------ 1 root root 64 May 13 13:03 3 -> /run/initd.lock   Once you have a process ID, you can resolve the path to the program:  sudo ls -lad /proc/3319/exe  lrwxrwxrwx 1 root root 0 May 14 00:48 /proc/3319/exe -> /tmp/x.bin   Exploring bpfdoor using strings  Running strings <path> reveals some interesting messages:  [-] Execute command failed /var/run/initd.lock   libtom/libtomcrypt has been bundled in, so we see lines such as:  LTC_ARGCHK '%s' failure on line %d of file %s X.509v%i certificate   Issued by: [%s]%s (%s)   Issued to: [%s]%s (%s, %s)   Subject: %s   Validity: %s - %s   OCSP: %s   Serial number: ... LibTomCrypt 1.17 (Tom St Denis, tomstdenis@gmail.com) LibTomCrypt is public domain software"
BPFDoor-unfinished.bike.csv,pid,file_6/get,ID,^PID.*,1,1,getppid() getpid(),"Here is another osquery and shell pair:  SELECT p.*,     COUNT(DISTINCT pmm.path) AS pmm_count FROM processes p     JOIN process_open_sockets pos ON p.pid = pos.pid     LEFT JOIN process_memory_map pmm ON p.pid = pmm.pid     AND pmm.path LIKE %.so.%     -- Yes, this is a weird performance optimization WHERE p.pid IN (         SELECT pid         FROM processes         WHERE p.euid = 0             AND p.path NOT IN (                 '/usr/bin/containerd',                 '/usr/bin/fusermount3',                 '/usr/sbin/acpid',                 '/usr/sbin/mcelog',                 '/usr/bin/docker-proxy'             )     ) GROUP BY pos.pid -- libc.so, ld-linux HAVING pmm_count = 2;   cd /proc || exit  for pid in *; do     [[ !"
BPFDoor-unfinished.bike.csv,Uid,continue/get,ID,^UID.*,1,1,getuid() geteuid(),-f ${pid}/exe || ${pid} =~ self ]] && continue      euid=$(grep Uid /proc/${pid}/status | awk '{ print $2 }')     [[ ${euid} != 0 ]] && continue      sockets=$(sudo find /proc/${pid}/fd -lname socket:* | wc -l)     [[ ${sockets} == 0 ]] && continue      libs=$(sudo find /proc/${pid}/map_files/ -type l -lname *.so
BPFDoor-unfinished.bike.csv,child_tidptr=0x7ff8d1b39a10),,MEM,"0x[0-9a-zA-Z]{1,16} (mem)",0,0,,"Running bpfdoor as a regular user  I first ran bpfdoor as an unprivileged user to see what system calls would be executed:  strace -o /tmp/st.user -f ./x.bin   I've removed the less interesting lines of output, but the program does astonishingly little:  2655  execve(./x.bin, [./x.bin], 0x7fff9dad6ff8 /* 23 vars */) = 0 2655  openat(AT_FDCWD, /lib/x86_64-linux-gnu/libc.so.6, O_RDONLY|O_CLOEXEC) = 3 2655  openat(AT_FDCWD, /var/run/initd.lock, O_RDWR|O_CREAT, 0666) = -1 EACCES (Permission denied) 2655  flock(-1, LOCK_EX|LOCK_NB)        = -1 EBADF (Bad file descriptor) 2655  clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7ff8d1b39a10) = 2656 2655  +++ exited with 0 +++ 2656  close(0)                          = 0 2656  close(1)                          = 0 2656  close(2)                          = 0 2656  setsid()                          = 2656 2656  getrandom(\xa4\xd5\x9d\x71\xb3\xe0\x98\xe1, 8, GRND_NONBLOCK) = 8 2656  socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL)) = -1 EPERM (Operation not permitted) 2656  exit_group(0)                     = ?"
BPFDoor-unfinished.bike.csv,0x7fff9dad6ff8,file_6,MEM,"0x[0-9a-zA-Z]{1,16} (mem)",0,0,,"Running bpfdoor as a regular user  I first ran bpfdoor as an unprivileged user to see what system calls would be executed:  strace -o /tmp/st.user -f ./x.bin   I've removed the less interesting lines of output, but the program does astonishingly little:  2655  execve(./x.bin, [./x.bin], 0x7fff9dad6ff8 /* 23 vars */) = 0 2655  openat(AT_FDCWD, /lib/x86_64-linux-gnu/libc.so.6, O_RDONLY|O_CLOEXEC) = 3 2655  openat(AT_FDCWD, /var/run/initd.lock, O_RDWR|O_CREAT, 0666) = -1 EACCES (Permission denied) 2655  flock(-1, LOCK_EX|LOCK_NB)        = -1 EBADF (Bad file descriptor) 2655  clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7ff8d1b39a10) = 2656 2655  +++ exited with 0 +++ 2656  close(0)                          = 0 2656  close(1)                          = 0 2656  close(2)                          = 0 2656  setsid()                          = 2656 2656  getrandom(\xa4\xd5\x9d\x71\xb3\xe0\x98\xe1, 8, GRND_NONBLOCK) = 8 2656  socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL)) = -1 EPERM (Operation not permitted) 2656  exit_group(0)                     = ?"
